<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Private Call ðŸ˜‰</title>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        :root {
            --dark-bg: #121212;
            --primary-accent: #007acc;
            --secondary-surface: #2a2a2a;
            --red-accent: #d93025;
            --red-accent-hover: #a52714;
        }

        body {
            background-color: var(--dark-bg);
            color: #e0e0e0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            margin: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
        }

        .main-content {
            height: 100%;
            width: 100%;
            display: flex;
        }

        #video-grid {
            flex-grow: 1;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 1rem;
            padding: 1rem;
            padding-bottom: 120px;
            box-sizing: border-box;
            transition: all 0.4s ease-in-out;
        }

        #video-grid.pinned-mode {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .video-container {
            position: relative;
            background-color: black;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.4s ease-in-out;
        }

        .video-container.pinned {
            flex-grow: 1;
            height: 85%;
        }

        #unpinned-bar {
            width: 100%;
            height: 15%;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
            padding-bottom: 5px;
        }

        .video-container.unpinned {
            height: 100%;
            width: auto;
            aspect-ratio: 16 / 9;
            flex-shrink: 0;
        }

        /* --- THE DEFINITIVE FIX --- */
        /* By default, no videos are mirrored. */
        video {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        /* ONLY mirror the local video feed. */
        #local-video {
            transform: scaleX(-1);
        }

        /* When the local video is a screen share, UN-MIRROR it. */
        #local-video.screen-share {
            transform: scaleX(1);
        }

        .username-overlay {
            position: absolute;
            bottom: 8px;
            left: 8px;
            background: rgba(0, 0, 0, 0.6);
            padding: 5px 10px;
            border-radius: 6px;
            z-index: 10;
        }


        .pin-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 32px;
            height: 32px;
            background-color: rgba(0, 0, 0, 0.6);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .video-container:hover .pin-btn {
            opacity: 1;
        }

        .mute-indicator {
            position: absolute;
            top: 8px;
            left: 8px;
            width: 32px;
            height: 32px;
            background-color: rgba(217, 48, 37, 0.8);
            border-radius: 6px;
            z-index: 10;
            display: none;
            /* Hidden by default */
            align-items: center;
            justify-content: center;
            color: white;
        }

        .mute-indicator.visible {
            display: flex;
            /* Shown when active */
        }

        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--secondary-surface);
            padding: 0.75rem;
            display: flex;
            gap: 0.75rem;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            z-index: 100;
        }

        #controls button {
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background-color: #4a4a4a;
            color: white;
            transition: background-color 0.2s ease, transform 0.1s ease;
            white-space: nowrap;
        }

        #controls button:hover {
            background-color: #5a5a5a;
        }

        #controls button:active {
            transform: scale(0.95);
        }

        #controls button.active {
            background-color: var(--red-accent);
        }

        #hangup-btn {
            background-color: var(--red-accent);
        }

        #hangup-btn:hover {
            background-color: var(--red-accent-hover);
        }

        /* --- NEW: Container for client-side controls --- */
        .client-controls {
            position: absolute;
            bottom: 8px;
            right: 8px;
            display: flex;
            gap: 8px;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 10;
        }

        .video-container:hover .client-controls {
            opacity: 1;
        }

        .client-controls button {
            width: 32px;
            height: 32px;
            background-color: rgba(0, 0, 0, 0.6);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
        }

        /* --- NEW MODAL STYLES --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            /* Hidden by default */
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        .modal-overlay.visible {
            display: flex;
            /* Show when active */
        }

        .modal-content {
            background-color: var(--secondary-surface);
            padding: 2rem;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
        }

        .modal-buttons {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .modal-buttons button {
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background-color: #4a4a4a;
            color: white;
        }

        #hd-quality-btn {
            background-color: var(--primary-accent);
        }

        /* --- NEW: Style for the speaking indicator --- */
        .video-container.is-speaking {
            border: 3px solid #007acc;
            /* A bright blue glow */
        }

        /* --- NEW CHAT STYLES --- */
        #chat-container {
            position: fixed;
            right: 0;
            top: 0;
            width: 300px;
            height: 100%;
            background-color: var(--secondary-surface);
            /* Changed to match theme */
            display: flex;
            flex-direction: column;
            border-left: 1px solid #444;
            z-index: 50;
            transition: transform 0.3s ease-in-out;
            transform: translateX(0);
        }

        #chat-container.hidden {
            transform: translateX(100%);
        }

        #chat-header {
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #444;
            font-weight: bold;
        }

        #close-chat-btn {
            background: none;
            border: none;
            color: #e0e0e0;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }

        #close-chat-btn:hover {
            color: var(--red-accent);
        }

        #messages {
            list-style-type: none;
            margin: 0;
            padding: 1rem;
            flex-grow: 1;
            overflow-y: auto;
        }

        #messages li {
            padding: 0.5rem 0;
            border-bottom: 1px solid #333;
        }

        #chat-form {
            padding: 1rem;
            display: flex;
        }

        #chat-input {
            border: 1px solid #444;
            padding: 0.75rem;
            flex-grow: 1;
            border-radius: 8px;
            margin-right: 1rem;
            background-color: var(--secondary-surface);
            color: white;
        }

        .suggestion-item:last-child {
            border-bottom: none;
        }

        .suggestion-item:hover,
        .suggestion-item.selected {
            background-color: var(--primary-accent);
            color: white;
        }

        .user-list-group {
            list-style: none;
            padding: 0;
            margin: 0;
            max-height: 400px;
            overflow-y: auto;
        }

        .user-list-group li {
            padding: 8px 12px;
            border-bottom: 1px solid #444;
            cursor: pointer;
            transition: background 0.2s;
        }

        .user-list-group li:hover {
            background-color: var(--secondary-surface);
        }
    </style>
</head>

<body>
    <main class="main-content">
        <div id="video-grid">
            <div class="video-container" id="local-video-container">
                <video id="local-video" autoplay muted playsinline></video>
                <div class="username-overlay">You</div>
            </div>
        </div>
    </main>

    <div id="chat-container">
        <div id="chat-header">
            <span>Chat</span>
            <button id="close-chat-btn" title="Close Chat">&times;</button>
        </div>
        <div id="messages"></div>
        <div id="command-suggestions"></div>
        <form id="chat-form">
            <input id="chat-input" autocomplete="off" placeholder="Type a message..." /><button id="send-btn"
                type="submit">âž¤</button>
        </form>
    </div>

    <div id="controls">
        <button id="mute-btn">Mute Mic</button>
        <button id="camera-btn">Turn Camera Off</button>
        <button id="screen-share-btn">Share Screen</button>
        <button id="chat-btn" class="active">Chat</button>
        <button id="hangup-btn">Hang Up</button>
    </div>

    <!-- ADMIN MODAL -->
    <div id="admin-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 id="admin-modal-title">Manage User</h2>
            <div id="admin-toggles"
                style="display: flex; flex-direction: column; gap: 10px; align-items: flex-start; margin: 20px 0;">
                <label><input type="checkbox" id="perm-chat"> Allow Chat</label>
                <label><input type="checkbox" id="perm-video"> Allow Video</label>
                <label><input type="checkbox" id="perm-audio"> Allow Audio</label>
                <label><input type="checkbox" id="perm-screen"> Allow Screen Share</label>
            </div>
            <br>
            <div id="superuser-password-section"
                style="display: none; border-top: 1px solid #444; padding-top: 10px; margin-top: 10px;">
                <h3>Change Password (Superuser)</h3>
                <input type="password" id="new-password-input" placeholder="New Password"
                    style="padding: 5px; color: black;">
                <button id="update-password-btn" style="padding: 5px; cursor: pointer;">Update</button>
            </div>

            <div class="modal-buttons">
                <button id="admin-close-btn">Close</button>
            </div>
        </div>
    </div>

    <!-- ADMIN USER LIST MODAL -->
    <div id="admin-user-list-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 600px;">
            <h2>All Users</h2>
            <div style="display: flex; gap: 20px;">
                <div style="flex: 1;">
                    <h3>Online</h3>
                    <ul id="admin-user-list-online" class="user-list-group"></ul>
                </div>
                <div style="flex: 1; border-left: 1px solid #444; padding-left: 20px;">
                    <h3>Offline</h3>
                    <ul id="admin-user-list-offline" class="user-list-group"></ul>
                </div>
            </div>
            <div class="modal-buttons">
                <button id="admin-user-list-close-btn">Close</button>
            </div>
        </div>
    </div>

    <script>
        const videoGrid = document.getElementById('video-grid');
        const localVideo = document.getElementById('local-video');
        const peerConnections = {};
        const audioAnalyzers = {};
        const remoteGainNodes = {}; // NEW: Store gain nodes for mute control
        let localStream, screenStream;
        let isScreenSharing = false;

        // --- Shared AudioContext to prevent limit errors and handle autoplay state ---
        let sharedAudioContext = null;

        // --- PERMISSIONS GLOBALS ---
        let myRole = 'user';
        let myPermissions = {};
        const remoteUsers = {}; // Store data of other users: { socketId: { username, role, permissions... } }

        function getSharedAudioContext() {
            if (!sharedAudioContext) {
                sharedAudioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (sharedAudioContext.state === 'suspended') {
                sharedAudioContext.resume().catch(console.error);
            }
            return sharedAudioContext;
        }

        // Resume AudioContext on any user interaction
        ['click', 'touchstart', 'keydown'].forEach(event => {
            document.body.addEventListener(event, () => {
                if (sharedAudioContext && sharedAudioContext.state === 'suspended') {
                    sharedAudioContext.resume();
                }
            }, { once: true });
        });

        // --- AUDIO MIXING GLOBALS ---
        let audioContext;
        let mixedAudioDest;
        let micSource;
        let screenAudioSource;
        let mixedAudioStream;

        function setupAudioMixing(micStream) {
            audioContext = new AudioContext();
            mixedAudioDest = audioContext.createMediaStreamDestination();

            if (micStream.getAudioTracks().length > 0) {
                micSource = audioContext.createMediaStreamSource(micStream);
                micSource.connect(mixedAudioDest);
            }

            mixedAudioStream = mixedAudioDest.stream;
        }

        function togglePin(containerToPin) {
            const isAlreadyPinned = containerToPin.classList.contains('pinned');
            videoGrid.classList.remove('pinned-mode');
            document.querySelectorAll('.video-container').forEach(c => {
                c.classList.remove('pinned', 'unpinned');
                if (c.parentElement.id === 'unpinned-bar') {
                    videoGrid.appendChild(c);
                }
            });
            const unpinnedBar = document.getElementById('unpinned-bar');
            if (unpinnedBar) unpinnedBar.remove();

            if (!isAlreadyPinned) {
                videoGrid.classList.add('pinned-mode');
                const newUnpinnedBar = document.createElement('div');
                newUnpinnedBar.id = 'unpinned-bar';
                document.querySelectorAll('.video-container').forEach(c => {
                    if (c === containerToPin) {
                        c.classList.add('pinned');
                    } else {
                        c.classList.add('unpinned');
                        newUnpinnedBar.appendChild(c);
                    }
                });
                videoGrid.appendChild(newUnpinnedBar);
            }
        }

        function setMuteIndicator(container, isMuted) {
            let indicator = container.querySelector('.mute-indicator');
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.className = 'mute-indicator';
                indicator.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 5L6 9H2v6h4l5 4V5z"></path><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line></svg>`;
                container.appendChild(indicator);
            }
            indicator.classList.toggle('visible', isMuted);
        }

        function addPinButton(videoContainer) {
            const pinBtn = document.createElement('button');
            pinBtn.className = 'pin-btn';
            pinBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 17.5V22M10 17.5h4M12 2a5 5 0 0 0-5 5c0 4.42 5 9.5 5 9.5s5-5.08 5-9.5a5 5 0 0 0-5-5z"/></svg>`;
            pinBtn.title = 'Pin Video';
            pinBtn.onclick = (e) => {
                e.stopPropagation();
                togglePin(videoContainer);
            };
            videoContainer.appendChild(pinBtn);
        }

        // --- NEW: Helper function to toggle the mute icon ---
        function setMuteIndicator(container, isMuted) {
            let indicator = container.querySelector('.mute-indicator');
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.className = 'mute-indicator';
                indicator.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 5L6 9H2v6h4l5 4V5z"></path><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line></svg>`;
                container.appendChild(indicator);
            }
            indicator.classList.toggle('visible', isMuted);
        }

        function setupLocalSpeakingIndicator(stream) {
            const container = document.getElementById('local-video-container');
            const audioContext = getSharedAudioContext();
            const analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;

            const source = audioContext.createMediaStreamSource(stream);
            source.connect(analyser);

            const dataArray = new Uint8Array(analyser.frequencyBinCount);

            function checkVolume() {
                analyser.getByteFrequencyData(dataArray);
                const average = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;

                // Use a threshold to detect speech
                if (average > 15) { // You can adjust this threshold
                    container.classList.add('is-speaking');
                } else {
                    container.classList.remove('is-speaking');
                }
                requestAnimationFrame(checkVolume);
            }
            requestAnimationFrame(checkVolume);
        }

        function enforcePermissions(perms, socket) {
            myPermissions = perms; // Update global state

            // 1. Chat
            const chatInput = document.getElementById('chat-input');
            if (chatInput) {
                chatInput.disabled = !perms.chat;
                chatInput.placeholder = perms.chat ? "Type a message..." : "Chat disabled by admin";
            }

            // 2. Video
            if (!perms.video && localStream) {
                const vidTrack = localStream.getVideoTracks()[0];
                if (vidTrack && vidTrack.enabled) {
                    vidTrack.enabled = false;
                    document.getElementById('camera-btn').click(); // Sync UI
                    alert("Your camera has been disabled by an admin.");
                }
            }

            // 3. Audio
            if (!perms.audio && localStream) {
                const audTrack = localStream.getAudioTracks()[0];
                if (audTrack && audTrack.enabled) {
                    audTrack.enabled = false;
                    // document.getElementById('mute-btn').click(); // Don't click, just sync UI to muted
                    const muteBtn = document.getElementById('mute-btn');
                    muteBtn.textContent = 'Unmute Mic';
                    muteBtn.classList.add('active'); // active means muted in this app design? Wait, let's check
                    // Logic: muteBtn.classList.toggle('active', isMuted);
                    // So YES, active = muted.
                    setMuteIndicator(document.getElementById('local-video-container'), true);
                    socket.emit('mute-status-changed', { isMuted: true });

                    alert("Your microphone has been disabled by an admin.");
                }
            }

            if (!perms.screen && isScreenSharing) {
                toggleScreenShare(false, socket); // Stop sharing immediately
                alert("Your screen share was stopped by an admin.");
            }
        }

        // --- GLOBAL: All Users Data (for Admin) ---
        let allUsers = [];

        async function main() {
            try {
                // Step 1: Get camera and mic access first.
                try {
                    localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                } catch (err) {
                    console.warn("Could not get camera + audio, trying audio only.", err);
                    localStream = await navigator.mediaDevices.getUserMedia({ video: false, audio: true });
                }
                localVideo.srcObject = localStream;
                addPinButton(document.getElementById('local-video-container'));

                // Initialize Audio Mixing with the Microphone stream
                setupAudioMixing(localStream);

                // Use the raw mic stream for the visualizer (still works)
                setupLocalSpeakingIndicator(localStream);

                // Step 2: Connect to the server.
                const token = localStorage.getItem('synapse-token');
                if (!token) { window.location.href = '/'; return; }
                const socket = io({ auth: { token } });

                // Step 3: Set up all signaling listeners.
                socket.on('my-identity', (data) => {
                    myRole = data.role;
                    myPermissions = data.permissions;
                    window.myUsername = data.username; // Capture username
                    enforcePermissions(myPermissions, socket);

                    // If admin or superuser, fetch all users
                    if (myRole === 'admin' || myRole === 'superuser') {
                        socket.emit('get-all-users');
                    }
                });

                socket.on('all-users-data', (data) => {
                    allUsers = data;
                });

                socket.on('permission-update', ({ feature, value }) => {
                    myPermissions[feature] = value;
                    enforcePermissions(myPermissions, socket);
                });

                socket.on('existing-users', (users) => {
                    for (const [socketId, userData] of Object.entries(users)) {
                        remoteUsers[socketId] = userData; // Track locally
                        createPeerConnection(socketId, true, userData, socket);
                    }
                });
                socket.on('user-joined', (socketId, userData) => {
                    remoteUsers[socketId] = userData; // Track locally

                    // --- NEW PROTECTION LOGIC ---
                    // Before adding the new user, check for and remove any "ghost" duplicates.
                    // This handles rapid reconnects where the 'user-left' event hasn't processed yet.
                    document.querySelectorAll('.video-container').forEach(container => {
                        const usernameDiv = container.querySelector('.username-overlay');
                        // If a container with the same username already exists (and isn't our own)
                        if (usernameDiv && usernameDiv.textContent === userData.username && container.id !== 'local-video-container') {
                            console.warn(`Duplicate user found for ${userData.username}. Cleaning up old connection.`);
                            const oldSocketId = container.id;

                            // Clean up all old resources associated with the ghost user
                            if (peerConnections[oldSocketId]) {
                                peerConnections[oldSocketId].close();
                                delete peerConnections[oldSocketId];
                            }
                            if (audioAnalyzers[oldSocketId]) {
                                cancelAnimationFrame(audioAnalyzers[oldSocketId].loopId);
                                delete audioAnalyzers[oldSocketId];
                            }
                            container.remove();
                        }
                    });
                    // --- END OF NEW LOGIC ---
                    // Now, create the connection for the new, legitimate user.
                    createPeerConnection(socketId, false, userData, socket);
                });
                socket.on('user-mute-status', (socketId, isMuted) => {
                    const container = document.getElementById(socketId);
                    if (container) setMuteIndicator(container, isMuted);
                });
                socket.on('webrtc-offer', (fromSocketId, offer) => { const pc = peerConnections[fromSocketId]; if (pc) { pc.setRemoteDescription(new RTCSessionDescription(offer)).then(() => pc.createAnswer()).then(answer => pc.setLocalDescription(answer)).then(() => socket.emit('webrtc-answer', fromSocketId, pc.localDescription)); } });
                socket.on('webrtc-answer', (fromSocketId, answer) => { const pc = peerConnections[fromSocketId]; if (pc) pc.setRemoteDescription(new RTCSessionDescription(answer)); });
                socket.on('webrtc-ice-candidate', (fromSocketId, candidate) => { const pc = peerConnections[fromSocketId]; if (pc) pc.addIceCandidate(new RTCIceCandidate(candidate)); });
                socket.on('user-left', (socketId) => {
                    // 1. Stop the audio analysis loop first to prevent errors
                    if (audioAnalyzers[socketId]) {
                        cancelAnimationFrame(audioAnalyzers[socketId].loopId);
                        delete audioAnalyzers[socketId];
                    }

                    // 2. Close the WebRTC connection
                    if (peerConnections[socketId]) {
                        peerConnections[socketId].close();
                        delete peerConnections[socketId];
                    }

                    // 3. Find and remove the video container from the screen
                    const containerToRemove = document.getElementById(socketId);
                    if (containerToRemove) {
                        // If the user who left was the one pinned, reset the layout
                        if (containerToRemove.classList.contains('pinned')) {
                            togglePin(containerToRemove); // This just unpins everyone
                        }
                        containerToRemove.remove();
                    }
                });

                // Step 4: Set up controls.
                const muteBtn = document.getElementById('mute-btn');
                muteBtn.addEventListener('click', () => {
                    // Permission Check
                    if (myPermissions && myPermissions.audio === false) {
                        return alert("Admin has successfully disabled your microphone.");
                    }

                    const audioTrack = localStream.getAudioTracks()[0];
                    if (audioTrack) {
                        audioTrack.enabled = !audioTrack.enabled;
                        const isMuted = !audioTrack.enabled;
                        muteBtn.textContent = isMuted ? 'Unmute Mic' : 'Mute Mic';
                        muteBtn.classList.toggle('active', isMuted);
                        setMuteIndicator(document.getElementById('local-video-container'), isMuted);
                        // This line tells everyone else you are muted
                        socket.emit('mute-status-changed', { isMuted });
                    }
                });

                const cameraBtn = document.getElementById('camera-btn');
                cameraBtn.addEventListener('click', () => {
                    if (isScreenSharing) return;
                    // Permission Check
                    if (myPermissions && myPermissions.video === false) {
                        return alert("Admin has successfully disabled your camera.");
                    }

                    const videoTrack = localStream.getVideoTracks()[0];
                    if (videoTrack) {
                        videoTrack.enabled = !videoTrack.enabled;
                        cameraBtn.textContent = videoTrack.enabled ? 'Turn Camera Off' : 'Turn Camera On';
                        cameraBtn.classList.toggle('active', !videoTrack.enabled);
                    }
                });

                // --- Chat Toggle Logic ---
                const chatContainer = document.getElementById('chat-container');
                const chatBtn = document.getElementById('chat-btn');
                const closeChatBtn = document.getElementById('close-chat-btn');

                function toggleChat() {
                    chatContainer.classList.toggle('hidden');
                    const isHidden = chatContainer.classList.contains('hidden');
                    chatBtn.classList.toggle('active', !isHidden);
                }

                chatBtn.addEventListener('click', toggleChat);
                closeChatBtn.addEventListener('click', toggleChat);

                document.getElementById('hangup-btn').addEventListener('click', () => { window.location.href = '/'; });

                // --- NEW LOGIC FOR SCREEN SHARE MODAL ---
                const qualityModal = document.getElementById('quality-modal');
                const standardQualityBtn = document.getElementById('standard-quality-btn');
                const hdQualityBtn = document.getElementById('hd-quality-btn');

                // The "Share Screen" button now opens the modal.
                document.getElementById('screen-share-btn').addEventListener('click', () => {
                    // Permission Check
                    if (!isScreenSharing && myPermissions && myPermissions.screen === false) {
                        return alert("Admin has successfully disabled your screen sharing.");
                    }

                    if (isScreenSharing) {
                        // If you're already sharing, just stop it.
                        toggleScreenShare(false, socket);
                    } else {
                        // Otherwise, show the quality options.
                        qualityModal.classList.add('visible');
                    }
                });

                // Listeners for the buttons inside the modal.
                standardQualityBtn.addEventListener('click', () => {
                    qualityModal.classList.remove('visible');
                    toggleScreenShare(false, socket); // isHD = false
                });

                hdQualityBtn.addEventListener('click', () => {
                    qualityModal.classList.remove('visible');
                    toggleScreenShare(true, socket); // isHD = true
                });

                // Hide the modal if the user clicks the background overlay.
                qualityModal.addEventListener('click', (e) => {
                    if (e.target === qualityModal) {
                        qualityModal.classList.remove('visible');
                    }
                });
                // Inside your main() function

                const messages = document.getElementById('messages');
                const chatForm = document.getElementById('chat-form');
                const chatInput = document.getElementById('chat-input');

                // --- CHAT HISTORY LOGIC ---
                const myMessageHistory = [];
                let historyIndex = -1;
                let currentDraft = '';

                // --- COMMAND SUGGESTIONS LOGIC ---
                // --- COMMAND SUGGESTIONS LOGIC ---
                const AVAILABLE_COMMANDS = [
                    { cmd: '/clearhistory', role: 'all' },
                    { cmd: '/clear', role: 'admin' },
                    { cmd: '/roll', role: 'all' },
                    { cmd: '/admin', role: 'admin' }
                ];
                const suggestionsContainer = document.getElementById('command-suggestions');
                let selectedSuggestionIndex = -1;

                function showSuggestions(query) {
                    suggestionsContainer.innerHTML = '';
                    selectedSuggestionIndex = -1;

                    if (!query || !query.startsWith('/')) {
                        suggestionsContainer.classList.remove('visible');
                        return;
                    }

                    // Filter commands based on role
                    // Superuser sees everything Admin sees
                    const matches = AVAILABLE_COMMANDS.filter(item => {
                        if (!item.cmd.startsWith(query)) return false;
                        if (item.role === 'admin' && (myRole !== 'admin' && myRole !== 'superuser')) return false;
                        return true;
                    });

                    // --- AUTOCOMPLETE FOR /admin ---
                    if (query.startsWith('/admin ')) {
                        const partial = query.substring(7);
                        // Filter allUsers
                        const userMatches = allUsers.filter(u => u.username.toLowerCase().startsWith(partial.toLowerCase()));

                        // Actually, if typing /admin space, only show users.
                        if (userMatches.length > 0) {
                            suggestionsContainer.innerHTML = ''; // Clear commands
                            userMatches.forEach(u => {
                                const div = document.createElement('div');
                                div.className = 'suggestion-item';
                                div.textContent = `/admin ${u.username}` + (u.isOnline ? '' : ' (offline)');
                                div.onclick = () => selectSuggestion(`/admin ${u.username}`);
                                suggestionsContainer.appendChild(div);
                            });
                            suggestionsContainer.classList.add('visible');
                            return;
                        }
                    }

                    if (matches.length === 0) {
                        suggestionsContainer.classList.remove('visible');
                        return;
                    }

                    matches.forEach((item, index) => {
                        const div = document.createElement('div');
                        div.className = 'suggestion-item';
                        div.textContent = item.cmd;
                        div.onclick = () => selectSuggestion(item.cmd);
                        suggestionsContainer.appendChild(div);
                    });

                    suggestionsContainer.classList.add('visible');
                }

                function selectSuggestion(cmd) {
                    chatInput.value = cmd + ' ';
                    suggestionsContainer.classList.remove('visible');
                    chatInput.focus();
                }

                function updateSuggestionSelection(direction) {
                    const items = suggestionsContainer.querySelectorAll('.suggestion-item');
                    if (items.length === 0) return;

                    if (selectedSuggestionIndex >= 0) {
                        items[selectedSuggestionIndex].classList.remove('selected');
                    }

                    if (direction === 'up') {
                        selectedSuggestionIndex = selectedSuggestionIndex > 0 ? selectedSuggestionIndex - 1 : items.length - 1;
                    } else {
                        selectedSuggestionIndex = selectedSuggestionIndex < items.length - 1 ? selectedSuggestionIndex + 1 : 0;
                    }

                    items[selectedSuggestionIndex].classList.add('selected');
                    items[selectedSuggestionIndex].scrollIntoView({ block: 'nearest' });
                }

                chatInput.addEventListener('input', (e) => {
                    const val = chatInput.value;
                    showSuggestions(val);
                });

                chatForm.addEventListener('submit', function (e) {
                    e.preventDefault();

                    // Aggressive cleanup
                    suggestionsContainer.classList.remove('visible');
                    suggestionsContainer.innerHTML = '';
                    selectedSuggestionIndex = -1;

                    if (chatInput.value) {
                        const msg = chatInput.value;

                        // --- LOCAL COMMAND: Clear History ---
                        if (msg.trim() === '/clearhistory') {
                            myMessageHistory.length = 0; // Clear array
                            historyIndex = -1;
                            addChatMessage({ username: 'System', message: 'Local typing history cleared.' });
                            chatInput.value = '';
                            return;
                        }

                        // --- ADMIN COMMAND: /admin [username] ---
                        if (msg.startsWith('/admin')) {
                            if (myRole !== 'admin' && myRole !== 'superuser') {
                                addChatMessage({ username: 'System', message: 'Unauthorized: Admin only.' });
                                chatInput.value = '';
                                return;
                            }

                            const parts = msg.trim().split(' ');

                            // Case 1: Just "/admin"
                            if (parts.length === 1) {
                                myMessageHistory.push(msg);
                                historyIndex = -1;
                                openUserListModal(socket);
                                chatInput.value = '';
                                return;
                            }

                            // Case 2: "/admin [username]"
                            const targetUsername = msg.substring(7).trim();
                            if (!targetUsername) {
                                // Fallback just in case split logic is weird
                                myMessageHistory.push(msg);
                                historyIndex = -1;
                                openUserListModal(socket);
                                chatInput.value = '';
                                return;
                            }

                            myMessageHistory.push(msg);
                            historyIndex = -1;

                            // Find in allUsers
                            const userObj = allUsers.find(u => u.username === targetUsername);

                            if (userObj) {
                                openAdminModal(userObj, socket); // Pass object, not socket ID
                                addChatMessage({ username: 'System', message: `Opened controls for ${targetUsername}` });
                            } else {
                                addChatMessage({ username: 'System', message: `User "${targetUsername}" not found in database.` });
                            }

                            chatInput.value = '';
                            return;
                        }

                        socket.emit('chat message', msg);

                        // Add to history if unique or just always add? Terminal usually adds always
                        // Only add if not empty (already checked)
                        myMessageHistory.push(msg);
                        historyIndex = -1; // Reset index on send

                        chatInput.value = '';
                    }
                });

                chatInput.addEventListener('keydown', (e) => {
                    // Check if suggestions are visible
                    if (suggestionsContainer.classList.contains('visible')) {
                        if (e.key === 'ArrowUp') {
                            e.preventDefault();
                            updateSuggestionSelection('up');
                            return;
                        } else if (e.key === 'ArrowDown') {
                            e.preventDefault();
                            updateSuggestionSelection('down');
                            return;
                        } else if (e.key === 'Enter' || e.key === 'Tab') {
                            if (selectedSuggestionIndex !== -1) {
                                e.preventDefault();
                                const items = suggestionsContainer.querySelectorAll('.suggestion-item');
                                selectSuggestion(items[selectedSuggestionIndex].textContent);
                            } else if (e.key === 'Tab') {
                                // If tab pressed without selection, select first? Or just allow default tab? 
                                // Let's select first match if tab is pressed
                                e.preventDefault();
                                const items = suggestionsContainer.querySelectorAll('.suggestion-item');
                                if (items.length > 0) selectSuggestion(items[0].textContent);
                            }
                            return;
                        } else if (e.key === 'Escape') {
                            suggestionsContainer.classList.remove('visible');
                            return;
                        }
                    }

                    if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        if (myMessageHistory.length === 0) return;

                        if (historyIndex === -1) {
                            // First time pressing up, go to last message
                            currentDraft = chatInput.value; // Save current input
                            historyIndex = myMessageHistory.length - 1;
                        } else if (historyIndex > 0) {
                            // Go back one more
                            historyIndex--;
                        }
                        chatInput.value = myMessageHistory[historyIndex];

                    } else if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        if (historyIndex === -1) return; // Already at present

                        if (historyIndex < myMessageHistory.length - 1) {
                            // Go forward one
                            historyIndex++;
                            chatInput.value = myMessageHistory[historyIndex];
                        } else {
                            // Back to present
                            historyIndex = -1;
                            chatInput.value = currentDraft; // Restore saved draft
                        }
                    }
                });

                // In private/call.html

                function addChatMessage({ username, message }) {
                    const item = document.createElement('li');

                    // XSS FIX: Create a text node/element first to sanitize the input
                    // We don't want to run replace() on raw HTML string if it contains scripts.
                    const tempDiv = document.createElement('div');
                    tempDiv.textContent = message;
                    const sanitizedMessage = tempDiv.textContent;

                    // Regular expression to find URLs in the message text
                    const urlRegex = /(\b(https?|ftp|file):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])|(\bwww\.[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig;

                    // Replace found URLs with clickable <a> tags
                    // Since we are running this on the sanitized text, it is safe-ish, 
                    // but we must be careful not to re-introduce HTML manually without encoding.
                    // The safest way is to split by URL and append nodes.
                    // For simplicity in this codebase, we will stick to innerHTML 
                    // BUT ONLY with the sanitized base string where < > are already escaped? 
                    // No, textContent doesn't escape for us if we read it back.
                    // Actually, let's just use a safer approach:

                    const messageContent = document.createElement('span');

                    // Split text by URLs and append text nodes or anchor tags
                    const parts = sanitizedMessage.split(urlRegex);
                    // The split with capturing groups is tricky.
                    // Let's use a simpler approach: Just textContent the username, then innerHTML the linked message
                    // but we need to ESCAPE the message first.

                    const escapeHtml = (unsafe) => {
                        return unsafe
                            .replace(/&/g, "&amp;")
                            .replace(/</g, "&lt;")
                            .replace(/>/g, "&gt;")
                            .replace(/"/g, "&quot;")
                            .replace(/'/g, "&#039;");
                    };

                    const safeMessage = escapeHtml(message);
                    const processedMessage = safeMessage.replace(urlRegex, (url) => {
                        let href = url;
                        if (!href.startsWith('http')) {
                            href = `http://${href}`;
                        }
                        return `<a href="${href}" target="_blank" rel="noopener noreferrer">${url}</a>`;
                    });

                    item.innerHTML = `<strong>${escapeHtml(username)}:</strong> ${processedMessage}`;
                    messages.appendChild(item);
                    messages.scrollTop = messages.scrollHeight;
                }

                socket.on('chat history', function (history) {
                    history.forEach(msg => addChatMessage(msg));
                });

                socket.on('chat message', function (msg) {
                    addChatMessage(msg);
                });

                socket.on('chat cleared', function () {
                    const messages = document.getElementById('messages');
                    messages.innerHTML = '';
                });

            } catch (err) {
                console.error("Fatal Error:", err);
                document.body.innerHTML = `<div style="text-align: center; padding-top: 50px;"><h1>Error</h1><p>Could not access camera/microphone. Please grant permission and refresh.</p></div>`;
            }
        }
        // Add these icon variables at the top of your script
        const speakerIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>`;
        const speakerOffIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 5L6 9H2v6h4l5 4V5z"></path><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line></svg>`;
        // This is the new function to add the separate mute buttons
        // This is the new function to add the separate mute buttons
        function addClientMuteControls(videoContainer, socket) {
            const controlsContainer = document.createElement('div');
            controlsContainer.className = 'client-controls';

            // Button to mute the user's voice (mic)
            const muteVoiceBtn = document.createElement('button');
            muteVoiceBtn.innerHTML = speakerIcon;
            muteVoiceBtn.title = 'Mute Voice';
            muteVoiceBtn.onclick = (e) => {
                e.stopPropagation();
                const socketId = videoContainer.id;
                const gainNode = remoteGainNodes[socketId];
                if (gainNode) {
                    // Toggle gain between 0 (muted) and 1 (unmuted)
                    const isMuted = gainNode.gain.value === 0;
                    gainNode.gain.value = isMuted ? 1 : 0;
                    muteVoiceBtn.innerHTML = isMuted ? speakerOffIcon : speakerIcon;
                } else {
                    muteVoiceBtn.innerHTML = speakerOffIcon;
                }
            };

            // Button to mute the stream's audio (screen share audio)
            const muteStreamBtn = document.createElement('button');
            muteStreamBtn.innerHTML = speakerIcon;
            muteStreamBtn.title = 'Mute Stream';
            muteStreamBtn.onclick = (e) => {
                e.stopPropagation();
                const videoEl = videoContainer.querySelector('video');
                if (videoEl) {
                    videoEl.muted = !videoEl.muted;
                    muteStreamBtn.innerHTML = videoEl.muted ? speakerOffIcon : speakerIcon;
                }
            };

            controlsContainer.appendChild(muteVoiceBtn);
            controlsContainer.appendChild(muteStreamBtn);

            // --- ADMIN CONTROLS ---
            if (myRole === 'admin' || myRole === 'superuser') {
                const adminBtn = document.createElement('button');
                adminBtn.innerText = 'âš™';
                adminBtn.title = 'Manage User';
                adminBtn.onclick = (e) => {
                    e.stopPropagation();
                    openAdminModal(videoContainer.id, socket);
                };
                controlsContainer.appendChild(adminBtn);
            }

            videoContainer.appendChild(controlsContainer);
        }

        // --- ADMIN USER LIST GUI ---
        function openUserListModal(socket) {
            const listModal = document.getElementById('admin-user-list-modal');
            const onlineList = document.getElementById('admin-user-list-online');
            const offlineList = document.getElementById('admin-user-list-offline');

            onlineList.innerHTML = '';
            offlineList.innerHTML = '';

            // Sort logic: A-Z
            const sortedUsers = [...allUsers].sort((a, b) => a.username.localeCompare(b.username));

            sortedUsers.forEach(user => {
                const li = document.createElement('li');
                li.textContent = user.username;
                li.onclick = () => {
                    listModal.classList.remove('visible');
                    openAdminModal(user, socket);
                };

                if (user.isOnline) {
                    onlineList.appendChild(li);
                } else {
                    offlineList.appendChild(li);
                }
            });

            listModal.classList.add('visible');

            const closeBtn = document.getElementById('admin-user-list-close-btn');
            closeBtn.onclick = () => listModal.classList.remove('visible');

            listModal.onclick = (e) => {
                if (e.target === listModal) listModal.classList.remove('visible');
            };
        }

        // --- ADMIN MODAL LOGIC (REFACTORED) ---
        function openAdminModal(targetUserOrId, socket) {
            let user;
            // It might be a socketId (click on video) or a user object (from /admin command)
            if (typeof targetUserOrId === 'string') {
                // It's a socketId from the video container
                user = remoteUsers[targetUserOrId];
            } else {
                // It's a user object from allUsers
                user = targetUserOrId;
            }

            if (!user) return;

            const modal = document.getElementById('admin-modal');
            const title = document.getElementById('admin-modal-title');
            title.innerText = `Manage ${user.username}` + (user.isOnline === false ? ' (Offline)' : '');

            const pChat = document.getElementById('perm-chat');
            const pVideo = document.getElementById('perm-video');
            const pAudio = document.getElementById('perm-audio');
            const pScreen = document.getElementById('perm-screen');

            // Set current state (default to true if missing)
            const perms = user.permissions || { chat: true, video: true, audio: true, screen: true };
            pChat.checked = perms.chat !== false;
            pVideo.checked = perms.video !== false;
            pAudio.checked = perms.audio !== false;
            pScreen.checked = perms.screen !== false;

            // CLIENT SAFEGUARD: Disable controls if managing self
            // We need to fetch our own username. We have 'socket' but we might need to access the cached identity.
            // Best way: check if targetUsername === myUsername (which we need to store globally or access via socket.id map if online)

            // We don't have a reliable global `myUsername` variable yet designated for this purpose, 
            // but we can derive it from `remoteUsers[socket.id]`? No, remoteUsers only has *others*.
            // Wait, standard practice: store own data in a variable. 
            // `socket.on('my-identity', data => ...)` gives us role/perms.
            // We need to store username too.
            // Let's check where 'my-identity' is handled. It doesn't seem to pass username?

            // Actually, for now, let's rely on server rejection as primary. 
            // But to be UX friendly, let's try to match logic. 

            // Wait, we can get username from `local-video-container .username-overlay`. 
            // Just assume 'You' is displayed? No.

            // Let's disable inputs if socketId matches `socket.id`.
            // BUT `socket.id` is not always available in scope easily unless we use the global `socket` object if available?
            // `socket` is passed to this function.

            const isSelf = (user.username === window.myUsername); // We need to add window.myUsername or similar.

            // Let's assume we can add `myUsername` global.
            if (isSelf) {
                [pChat, pVideo, pAudio, pScreen].forEach(el => el.disabled = true);
                title.innerText += " (You)";
            } else {
                [pChat, pVideo, pAudio, pScreen].forEach(el => el.disabled = false);
            }

            // Update Handler
            // We need to remove old listeners to avoid closure hell or multiple events? 
            // Simplest way: just re-assign onclick.

            function updatePerm(feature, value) {
                // Optimistic update
                if (!user.permissions) user.permissions = {};
                user.permissions[feature] = value;

                // Send USERNAME, not Socket ID
                socket.emit('admin-update-permission', { targetUsername: user.username, feature, value });
            }

            pChat.onclick = () => updatePerm('chat', pChat.checked);
            pVideo.onclick = () => updatePerm('video', pVideo.checked);
            pAudio.onclick = () => updatePerm('audio', pAudio.checked);
            pScreen.onclick = () => updatePerm('screen', pScreen.checked);

            // --- SUPERUSER: Change Password Section ---
            const passwordSection = document.getElementById('superuser-password-section');
            if (myRole === 'superuser') {
                passwordSection.style.display = 'block';
                const newPassInput = document.getElementById('new-password-input');
                const updatePassBtn = document.getElementById('update-password-btn');

                updatePassBtn.onclick = () => {
                    const newPass = newPassInput.value;
                    if (newPass) {
                        socket.emit('superuser-change-password', { targetUsername: user.username, newPassword: newPass });
                        newPassInput.value = ''; // clear after send
                    }
                };
            } else {
                passwordSection.style.display = 'none';
            }

            modal.classList.add('visible');

            // Close logic
            const closeBtn = document.getElementById('admin-close-btn');
            closeBtn.onclick = () => modal.classList.remove('visible');

            // Click outside
            modal.onclick = (e) => { if (e.target === modal) modal.classList.remove('visible'); };
        }

        async function createPeerConnection(socketId, isInitiator, userData, socket) {
            // Fetch ICE servers from our own backend to fix network issues
            let iceServers = [{ urls: 'stun:stun.l.google.com:19302' }]; // Fallback
            try {
                const response = await fetch('/api/ice-config');
                if (response.ok) {
                    iceServers = await response.json();
                }
            } catch (e) {
                console.error("Failed to fetch ICE config, using default STUN", e);
            }

            const pc = new RTCPeerConnection({ iceServers });
            peerConnections[socketId] = pc;

            // --- Sending logic UPDATED for Audio Mixing ---
            // 1. Add the VIDEO track (either Camera or Screen)
            const videoStream = isScreenSharing ? screenStream : localStream;
            videoStream.getVideoTracks().forEach(track => pc.addTrack(track, videoStream));

            // 2. Add the MIXED AUDIO track (Always the same track!)
            if (mixedAudioStream && mixedAudioStream.getAudioTracks().length > 0) {
                const mixedTrack = mixedAudioStream.getAudioTracks()[0];
                pc.addTrack(mixedTrack, mixedAudioStream);
            }

            pc.onicecandidate = (event) => { if (event.candidate) { socket.emit('webrtc-ice-candidate', socketId, event.candidate); } };

            // --- THIS IS THE CORRECTED RECEIVING LOGIC ---
            pc.ontrack = (event) => {
                let videoContainer = document.getElementById(socketId);
                if (!videoContainer) {
                    videoContainer = document.createElement('div');
                    videoContainer.id = socketId;
                    videoContainer.className = 'video-container';
                    const remoteVideo = document.createElement('video');
                    remoteVideo.autoplay = true;
                    remoteVideo.playsInline = true;
                    const micAudio = document.createElement('audio');
                    micAudio.autoplay = true;
                    micAudio.className = 'mic-audio';
                    const usernameDiv = document.createElement('div');
                    usernameDiv.className = 'username-overlay';
                    usernameDiv.textContent = userData.username;
                    videoContainer.appendChild(remoteVideo);
                    videoContainer.appendChild(micAudio);
                    videoContainer.appendChild(usernameDiv);
                    addPinButton(videoContainer);
                    addClientMuteControls(videoContainer, socket);
                    videoGrid.appendChild(videoContainer);
                    setMuteIndicator(videoContainer, userData.isMuted);
                }

                const videoEl = videoContainer.querySelector('video');
                const audioEl = videoContainer.querySelector('.mic-audio');

                if (event.track.kind === 'video') {
                    // Always put video tracks in the video element.
                    videoEl.srcObject = new MediaStream([event.track]);
                } else if (event.track.kind === 'audio') {
                    // If the invisible audio element is empty, this must be the microphone.
                    if (!audioEl.srcObject) {
                        const micStream = new MediaStream([event.track]);
                        audioEl.srcObject = micStream;

                        // --- Robust Speaking Indicator & Muting via Web Audio ---
                        const audioContext = getSharedAudioContext();
                        // Workaround: Chrome need element muted + playing, but we route audio via API
                        audioEl.muted = true;

                        const source = audioContext.createMediaStreamSource(micStream);
                        const gainNode = audioContext.createGain();
                        const analyser = audioContext.createAnalyser();
                        analyser.fftSize = 256;

                        // Route: Source -> Gain -> Analyser -> Speakers
                        source.connect(gainNode);
                        gainNode.connect(analyser);
                        analyser.connect(audioContext.destination);

                        // Store GainNode
                        remoteGainNodes[socketId] = gainNode;

                        const dataArray = new Uint8Array(analyser.frequencyBinCount);

                        if (audioAnalyzers[socketId]) {
                            cancelAnimationFrame(audioAnalyzers[socketId].loopId);
                        }

                        function checkVolume() {
                            analyser.getByteFrequencyData(dataArray);
                            const average = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;

                            if (average > 15) {
                                videoContainer.classList.add('is-speaking');
                            } else {
                                videoContainer.classList.remove('is-speaking');
                            }
                            if (audioAnalyzers[socketId]) {
                                audioAnalyzers[socketId].loopId = requestAnimationFrame(checkVolume);
                            }
                        }
                        audioAnalyzers[socketId] = { loopId: requestAnimationFrame(checkVolume) };
                        // setupSpeakingIndicator(videoContainer, micStream, socketId); // Replaced by inline logic above
                    } else { // Otherwise, this must be the screen share audio.
                        // Add this audio track to the video element's stream.
                        if (videoEl.srcObject) {
                            videoEl.srcObject.addTrack(event.track);
                        }
                    }
                }
            };

            if (isInitiator) { pc.createOffer().then(offer => pc.setLocalDescription(offer)).then(() => socket.emit('webrtc-offer', socketId, pc.localDescription)); }
        }
        async function toggleScreenShare(isHD, socket) {
            const screenShareBtn = document.getElementById('screen-share-btn');
            if (!isScreenSharing) {
                try {
                    const displayMediaOptions = {
                        video: isHD ? { cursor: "always", width: { ideal: 1920 }, height: { ideal: 1080 }, frameRate: { ideal: 60 } } : true,
                        audio: true
                    };

                    screenStream = await navigator.mediaDevices.getDisplayMedia(displayMediaOptions);
                    isScreenSharing = true;

                    // Show screen on local video
                    localVideo.srcObject = screenStream;
                    localVideo.style.transform = 'scaleX(1)';

                    // --- AUDIO MIXING LOGIC ---
                    // If shared screen has audio, mix it into the destination
                    if (screenStream.getAudioTracks().length > 0) {
                        screenAudioSource = audioContext.createMediaStreamSource(screenStream);
                        screenAudioSource.connect(mixedAudioDest);
                    }

                    // Replace ONLY the video track
                    await replaceTrack(screenStream.getVideoTracks()[0]);

                    screenShareBtn.textContent = 'Stop Sharing';
                    screenShareBtn.classList.add('active');

                    // Handle user clicking "Stop Sharing" on the browser UI
                    screenStream.getVideoTracks()[0].onended = () => { if (isScreenSharing) { toggleScreenShare(false, socket); } };

                } catch (err) { console.error("Screen share error", err); isScreenSharing = false; }
            } else {
                isScreenSharing = false;
                localVideo.srcObject = localStream;
                localVideo.style.transform = 'scaleX(-1)';

                // --- AUDIO CLEANUP LOGIC ---
                if (screenAudioSource) {
                    screenAudioSource.disconnect();
                    screenAudioSource = null;
                }

                // Replace ONLY the video track back to camera
                await replaceTrack(localStream.getVideoTracks()[0]);

                screenShareBtn.textContent = 'Share Screen';
                screenShareBtn.classList.remove('active');

                // Delay stopping the tracks to ensure the replacement frame arrives
                setTimeout(() => {
                    screenStream.getTracks().forEach(track => track.stop());
                }, 500);
            }
        }

        async function replaceTrack(newTrack) {
            for (const pc of Object.values(peerConnections)) {
                // Find the sender responsible for that type of track (video or audio)
                const sender = pc.getSenders().find(s => s.track && s.track.kind === newTrack.kind);
                if (sender) {
                    // Seamlessly replace the track being sent
                    await sender.replaceTrack(newTrack);
                }
            }
        }

        main();
    </script>

    <div id="quality-modal" class="modal-overlay">
        <div class="modal-content">
            <h2>Choose Screen Share Quality</h2>
            <div class="modal-buttons">
                <button id="standard-quality-btn">Standard</button>
                <button id="hd-quality-btn">High Quality (HD)</button>
            </div>
        </div>
    </div>

</body>

</html>