<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Private Call ðŸ˜‰</title>


    <script src="/socket.io/socket.io.js"></script>
    <style>
        :root {
            --dark-bg: #121212;
            --primary-accent: #007acc;
            --secondary-surface: #2a2a2a;
            --red-accent: #d93025;
            --red-accent-hover: #a52714;
        }

        body {
            background-color: var(--dark-bg);
            color: #e0e0e0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            margin: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
        }

        .main-content {
            height: 100%;
            width: 100%;
            display: flex;
        }

        #video-grid {
            flex-grow: 1;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 1rem;
            padding: 1rem;
            padding-bottom: 120px;
            box-sizing: border-box;
            transition: all 0.4s ease-in-out;
        }

        #video-grid.pinned-mode {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .video-container {
            position: relative;
            background-color: black;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.4s ease-in-out;
        }

        .video-container.pinned {
            flex-grow: 1;
            height: 85%;
        }

        /* New Error Message Style */
        .chat-message.system-error {
            color: #ff4d4d;
            font-weight: bold;
        }

        #unpinned-bar {
            width: 100%;
            height: 15%;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
            padding-bottom: 5px;
        }

        .video-container.unpinned {
            height: 100%;
            width: auto;
            aspect-ratio: 16 / 9;
            flex-shrink: 0;
        }

        /* --- THE DEFINITIVE FIX --- */
        /* By default, no videos are mirrored. */
        video {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        /* ONLY mirror the local video feed. */
        #local-video {
            transform: scaleX(-1);
        }

        /* When the local video is a screen share, UN-MIRROR it. */
        #local-video.screen-share {
            transform: scaleX(1);
        }

        .username-overlay {
            position: absolute;
            bottom: 8px;
            left: 8px;
            background: rgba(0, 0, 0, 0.6);
            padding: 5px 10px;
            border-radius: 6px;
            z-index: 10;
        }


        .pin-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 32px;
            height: 32px;
            background-color: rgba(0, 0, 0, 0.6);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .video-container:hover .pin-btn {
            opacity: 1;
        }

        .mute-indicator {
            position: absolute;
            top: 8px;
            left: 8px;
            width: 32px;
            height: 32px;
            background-color: rgba(217, 48, 37, 0.8);
            border-radius: 6px;
            z-index: 10;
            display: none;
            /* Hidden by default */
            align-items: center;
            justify-content: center;
            color: white;
        }

        .mute-indicator.visible {
            display: flex;
            /* Shown when active */
        }

        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--secondary-surface);
            padding: 0.75rem;
            display: flex;
            gap: 0.75rem;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            z-index: 100;
        }

        #controls button {
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background-color: #4a4a4a;
            color: white;
            transition: background-color 0.2s ease, transform 0.1s ease;
            white-space: nowrap;
        }

        #controls button:hover {
            background-color: #5a5a5a;
        }

        #controls button:active {
            transform: scale(0.95);
        }

        #controls button.active {
            background-color: var(--red-accent);
        }

        #hangup-btn {
            background-color: var(--red-accent);
        }

        #hangup-btn:hover {
            background-color: var(--red-accent-hover);
        }

        /* --- NEW: Container for client-side controls --- */
        .client-controls {
            position: absolute;
            bottom: 8px;
            right: 8px;
            display: flex;
            gap: 8px;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 10;
        }

        .video-container:hover .client-controls {
            opacity: 1;
        }

        .client-controls button {
            width: 32px;
            height: 32px;
            background-color: rgba(0, 0, 0, 0.6);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
        }

        /* --- NEW MODAL STYLES --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            /* Hidden by default */
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        .modal-overlay.visible {
            display: flex;
            /* Show when active */
        }

        .modal-content {
            background-color: var(--secondary-surface);
            padding: 2rem;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
        }

        .modal-buttons {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .modal-buttons button {
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background-color: #4a4a4a;
            color: white;
        }

        #hd-quality-btn {
            background-color: var(--primary-accent);
        }

        /* --- NEW: Style for the speaking indicator --- */
        .video-container.is-speaking {
            border: 3px solid #007acc;
            /* A bright blue glow */
        }

        /* --- NEW CHAT STYLES --- */
        #chat-container {
            position: fixed;
            right: 0;
            top: 0;
            width: 300px;
            height: 100%;
            background-color: var(--secondary-surface);
            /* Changed to match theme */
            display: flex;
            flex-direction: column;
            border-left: 1px solid #444;
            z-index: 50;
            transition: transform 0.3s ease-in-out;
            transition: transform 0.3s ease-in-out;
            transform: translateX(0);
        }

        /* --- TABS CSS --- */
        #chat-tabs {
            display: flex;
            background: #202124;
            border-bottom: 1px solid #444;
            padding: 5px 5px 0 5px;
            overflow-x: auto;
            flex-shrink: 0;
            white-space: nowrap;
        }

        .chat-tab {
            background: #2a2a2a;
            border: 1px solid #444;
            border-bottom: none;
            color: #aaa;
            padding: 5px 10px;
            margin-right: 2px;
            cursor: pointer;
            border-radius: 4px 4px 0 0;
            font-size: 0.9em;
            position: relative;
        }

        .chat-tab:hover {
            background: #333;
            color: #eee;
        }

        .chat-tab.active {
            background: #3c4043;
            color: #fff;
            border-color: #555;
            font-weight: bold;
        }

        .chat-tab .close-tab {
            margin-left: 5px;
            font-size: 0.8em;
            color: #888;
            border-radius: 50%;
            padding: 0 4px;
        }

        .chat-tab .close-tab:hover {
            background: #d93025;
            color: white;
        }

        .chat-tab.unread::after {
            content: 'â€¢';
            color: #d93025;
            position: absolute;
            top: 2px;
            right: 4px;
            font-size: 1.2em;
            line-height: 0.5;
        }

        #chat-container.hidden {
            transform: translateX(100%);
        }

        #chat-header {
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #444;
            font-weight: bold;
        }

        #close-chat-btn {
            background: none;
            border: none;
            color: #e0e0e0;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }

        #close-chat-btn:hover {
            color: var(--red-accent);
        }

        #messages {
            list-style-type: none;
            margin: 0;
            padding: 1rem;
            flex-grow: 1;
            overflow-y: auto;
        }

        #messages li {
            padding: 0.5rem 0;
            border-bottom: 1px solid #333;
        }

        #chat-form {
            padding: 1rem;
            display: flex;
        }

        #chat-input {
            border: 1px solid #444;
            padding: 0.75rem;
            flex-grow: 1;
            border-radius: 8px;
            margin-right: 1rem;
            background-color: var(--secondary-surface);
            color: white;
        }

        .suggestion-item:last-child {
            border-bottom: none;
        }

        .suggestion-item:hover,
        .suggestion-item.selected {
            background-color: var(--primary-accent);
            color: white;
        }

        .user-list-group {
            list-style: none;
            padding: 0;
            margin: 0;
            max-height: 400px;
            overflow-y: auto;
        }

        .user-list-group li {
            padding: 8px 12px;
            border-bottom: 1px solid #444;
            cursor: pointer;
            transition: background 0.2s;
        }

        .user-list-group li:hover {
            background-color: var(--secondary-surface);
        }

        /* --- TABS --- */
        .chat-tabs {
            display: none;
            /* Hidden by default */
            border-bottom: 1px solid #444;
        }

        .chat-tab {
            flex: 1;
            padding: 10px;
            background: none;
            border: none;
            color: #aaa;
            cursor: pointer;
            font-weight: bold;
        }

        .chat-tab.active {
            color: white;
            border-bottom: 2px solid var(--primary-accent);
        }

        #system-messages {
            display: none;
            /* Hidden by default */
            list-style-type: none;
            margin: 0;
            padding: 1rem;
            flex-grow: 1;
            overflow-y: auto;
        }
    </style>
</head>

<body>
    <main class="main-content">
        <div id="video-grid">
            <div class="video-container" id="local-video-container">
                <video id="local-video" autoplay muted playsinline></video>
                <div class="username-overlay">You</div>
            </div>
        </div>
    </main>

    <div id="chat-container" class="hidden">
        <div id="chat-header">
            <span>Chat</span>
            <button id="close-chat-btn">Ã—</button>
        </div>

        <!-- TABS BAR -->
        <div id="chat-tabs">
            <button class="chat-tab active" data-tab="public" onclick="switchTab('public')">Public</button>
            <button class="chat-tab" data-tab="system" id="tab-btn-system" style="display:none;"
                onclick="switchTab('system')">Local</button>
        </div>

        <!-- MESSAGES AREA -->
        <div id="chat-messages-area"
            style="flex:1; position:relative; overflow:hidden; display:flex; flex-direction:column;">
            <!-- Public Container -->
            <ul id="messages" class="message-list active"
                style="flex:1; overflow-y:auto; padding:1rem; margin:0; list-style:none;"></ul>

            <!-- System Container -->
            <ul id="system-messages" class="message-list"
                style="display:none; flex:1; overflow-y:auto; padding:1rem; margin:0; list-style:none;"></ul>
        </div>

        <div id="command-suggestions"></div>
        <form id="chat-form">
            <input id="chat-input" autocomplete="off" placeholder="Type a message..." /><button id="send-btn"
                type="submit">âž¤</button>
        </form>
    </div>

    <div id="controls">
        <button id="mute-btn">Mute Mic</button>
        <button id="camera-btn">Turn Camera Off</button>
        <button id="screen-share-btn">Share Screen</button>
        <button id="chat-btn" class="active">Chat</button>
        <button id="hangup-btn">Hang Up</button>
    </div>

    <!-- ADMIN MODAL -->
    <div id="admin-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 id="admin-modal-title">Manage User</h2>
            <div id="admin-toggles"
                style="display: flex; flex-direction: column; gap: 10px; align-items: flex-start; margin: 20px 0;">
                <label><input type="checkbox" id="perm-chat"> Allow Chat</label>
                <label><input type="checkbox" id="perm-video"> Allow Video</label>
                <label><input type="checkbox" id="perm-audio"> Allow Audio</label>
                <label><input type="checkbox" id="perm-screen"> Allow Screen Share</label>
            </div>
            <br>
            <br>
            <div id="superuser-role-section"
                style="display: none; margin-top: 10px; border-top: 1px solid #444; padding-top: 10px;">
                <h3>Role (Superuser)</h3>
                <select id="role-select" style="padding: 5px; color: black; background: white;">
                    <option value="user">User</option>
                    <option value="admin">Admin</option>
                </select>
            </div>
            <div id="superuser-password-section"
                style="display: none; border-top: 1px solid #444; padding-top: 10px; margin-top: 10px;">
                <h3>Change Password (Superuser)</h3>
                <input type="password" id="new-password-input" placeholder="New Password"
                    style="padding: 5px; color: black;">
                <button id="update-password-btn" style="padding: 5px; cursor: pointer;">Update</button>
            </div>

            <div class="modal-buttons">
                <button id="admin-close-btn">Close</button>
            </div>
        </div>
    </div>

    <!-- ADMIN USER LIST MODAL -->
    <div id="admin-user-list-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 600px;">
            <h2>All Users</h2>
            <div style="display: flex; gap: 20px;">
                <div style="flex: 1;">
                    <h3>Online</h3>
                    <ul id="admin-user-list-online" class="user-list-group"></ul>
                </div>
                <div style="flex: 1; border-left: 1px solid #444; padding-left: 20px;">
                    <h3>Offline</h3>
                    <ul id="admin-user-list-offline" class="user-list-group"></ul>
                </div>
            </div>
            <div class="modal-buttons">
                <button id="admin-user-list-close-btn">Close</button>
            </div>
        </div>
    </div>

    <!-- MY HISTORY MODAL -->
    <div id="history-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 500px;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                <h2>My Local History</h2>
                <span id="history-close-btn" class="close-btn">&times;</span>
            </div>
            <div style="margin-bottom:10px; display:flex; justify-content:space-between; align-items:center;">
                <label>Limit: <input id="history-limit-input" type="number" style="width:60px;" min="-1" /></label>
                <button id="history-clear-all-btn"
                    style="background:#d32f2f; color:white; border:none; padding:5px 10px; cursor:pointer;">Clear
                    All</button>
            </div>
            <ul id="history-list"
                style="list-style:none; padding:0; max-height:300px; overflow-y:auto; border:1px solid #444;">
            </ul>
        </div>
    </div>

    <!-- LOGS MODAL -->
    <div id="logs-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 800px; height: 80vh; display: flex; flex-direction: column;">
            <div class="modal-header">
                <h3>Server Logs</h3>
                <span id="logs-close-btn" class="close-btn">&times;</span>
            </div>
            <div class="modal-body" style="flex: 1; overflow: hidden; display: flex; flex-direction: column;">
                <div style="margin-bottom: 10px;">
                    <button id="logs-refresh-btn" style="padding: 5px 10px; cursor: pointer;">Refresh</button>
                    <button id="logs-clear-local-btn"
                        style="padding: 5px 10px; cursor: pointer; background: #e74c3c; color: white; border: none;">Clear
                        View</button>
                </div>
                <div id="logs-container"
                    style="flex: 1; overflow-y: auto; background: #000; color: #0f0; padding: 10px; font-family: monospace; font-size: 12px; white-space: pre-wrap;">
                </div>
            </div>
        </div>
    </div>
    Limit: <input type="number" id="history-limit-input" min="1" max="500"
        style="width:50px; padding:2px; background:#333; color:white; border:1px solid #555; text-align:center;">
    </label>
    </div>
    <ul id="history-list" style="list-style: none; padding: 0; max-height: 400px; overflow-y: auto; text-align: left;">
    </ul>
    <div class="modal-buttons">
        <button id="history-clear-all-btn" style="background-color: #d93025;">Clear All</button>
        <button id="history-close-btn">Close</button>
    </div>
    </div>
    </div>

    <script>
        const videoGrid = document.getElementById('video-grid');
        const localVideo = document.getElementById('local-video');
        const peerConnections = {};
        const audioAnalyzers = {};
        const remoteGainNodes = {}; // NEW: Store gain nodes for mute control
        let localStream, screenStream;
        let isScreenSharing = false;

        // --- Shared AudioContext to prevent limit errors and handle autoplay state ---
        let sharedAudioContext = null;

        // --- PERMISSIONS GLOBALS ---
        let myRole = 'user';
        let myPermissions = {};
        const remoteUsers = {}; // Store data of other users: { socketId: { username, role, permissions... } }

        function getSharedAudioContext() {
            if (!sharedAudioContext) {
                sharedAudioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (sharedAudioContext.state === 'suspended') {
                sharedAudioContext.resume().catch(console.error);
            }
            return sharedAudioContext;
        }

        // Resume AudioContext on any user interaction
        ['click', 'touchstart', 'keydown'].forEach(event => {
            document.body.addEventListener(event, () => {
                if (sharedAudioContext && sharedAudioContext.state === 'suspended') {
                    sharedAudioContext.resume();
                }
            }, { once: true });
        });

        // --- AUDIO MIXING GLOBALS ---
        let audioContext;
        let mixedAudioDest;
        let micSource;
        let screenAudioSource;
        let mixedAudioStream;

        function setupAudioMixing(micStream) {
            audioContext = new AudioContext();
            mixedAudioDest = audioContext.createMediaStreamDestination();

            if (micStream.getAudioTracks().length > 0) {
                micSource = audioContext.createMediaStreamSource(micStream);
                micSource.connect(mixedAudioDest);
            }

            mixedAudioStream = mixedAudioDest.stream;
        }

        function togglePin(containerToPin) {
            const isAlreadyPinned = containerToPin.classList.contains('pinned');
            videoGrid.classList.remove('pinned-mode');
            document.querySelectorAll('.video-container').forEach(c => {
                c.classList.remove('pinned', 'unpinned');
                if (c.parentElement.id === 'unpinned-bar') {
                    videoGrid.appendChild(c);
                }
            });
            const unpinnedBar = document.getElementById('unpinned-bar');
            if (unpinnedBar) unpinnedBar.remove();

            if (!isAlreadyPinned) {
                videoGrid.classList.add('pinned-mode');
                const newUnpinnedBar = document.createElement('div');
                newUnpinnedBar.id = 'unpinned-bar';
                document.querySelectorAll('.video-container').forEach(c => {
                    if (c === containerToPin) {
                        c.classList.add('pinned');
                    } else {
                        c.classList.add('unpinned');
                        newUnpinnedBar.appendChild(c);
                    }
                });
                videoGrid.appendChild(newUnpinnedBar);
            }
        }

        function setMuteIndicator(container, isMuted) {
            let indicator = container.querySelector('.mute-indicator');
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.className = 'mute-indicator';
                indicator.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 5L6 9H2v6h4l5 4V5z"></path><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line></svg>`;
                container.appendChild(indicator);
            }
            indicator.classList.toggle('visible', isMuted);
        }

        function addPinButton(videoContainer) {
            const pinBtn = document.createElement('button');
            pinBtn.className = 'pin-btn';
            pinBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 17.5V22M10 17.5h4M12 2a5 5 0 0 0-5 5c0 4.42 5 9.5 5 9.5s5-5.08 5-9.5a5 5 0 0 0-5-5z"/></svg>`;
            pinBtn.title = 'Pin Video';
            pinBtn.onclick = (e) => {
                e.stopPropagation();
                togglePin(videoContainer);
            };
            videoContainer.appendChild(pinBtn);
        }

        // --- NEW: Helper function to toggle the mute icon ---
        function setMuteIndicator(container, isMuted) {
            let indicator = container.querySelector('.mute-indicator');
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.className = 'mute-indicator';
                indicator.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 5L6 9H2v6h4l5 4V5z"></path><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line></svg>`;
                container.appendChild(indicator);
            }
            indicator.classList.toggle('visible', isMuted);
        }

        function setupLocalSpeakingIndicator(stream) {
            const container = document.getElementById('local-video-container');
            const audioContext = getSharedAudioContext();
            const analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;

            const source = audioContext.createMediaStreamSource(stream);
            source.connect(analyser);

            const dataArray = new Uint8Array(analyser.frequencyBinCount);

            function checkVolume() {
                analyser.getByteFrequencyData(dataArray);
                const average = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;

                // Use a threshold to detect speech
                if (average > 15) { // You can adjust this threshold
                    container.classList.add('is-speaking');
                } else {
                    container.classList.remove('is-speaking');
                }
                requestAnimationFrame(checkVolume);
            }
            requestAnimationFrame(checkVolume);
        }

        function enforcePermissions(perms, socket) {
            myPermissions = perms; // Update global state

            // 1. Chat
            const chatInput = document.getElementById('chat-input');
            if (chatInput) {
                chatInput.disabled = !perms.chat;
                chatInput.placeholder = perms.chat ? "Type a message..." : "Chat disabled by admin";
            }

            // 2. Video
            if (!perms.video && localStream) {
                const vidTrack = localStream.getVideoTracks()[0];
                if (vidTrack && vidTrack.enabled) {
                    vidTrack.enabled = false;
                    document.getElementById('camera-btn').click(); // Sync UI
                    alert("Your camera has been disabled by an admin.");
                }
            }

            // 3. Audio
            if (!perms.audio && localStream) {
                const audTrack = localStream.getAudioTracks()[0];
                if (audTrack && audTrack.enabled) {
                    audTrack.enabled = false;
                    // document.getElementById('mute-btn').click(); // Don't click, just sync UI to muted
                    const muteBtn = document.getElementById('mute-btn');
                    muteBtn.textContent = 'Unmute Mic';
                    muteBtn.classList.add('active'); // active means muted in this app design? Wait, let's check
                    // Logic: muteBtn.classList.toggle('active', isMuted);
                    // So YES, active = muted.
                    setMuteIndicator(document.getElementById('local-video-container'), true);
                    socket.emit('mute-status-changed', { isMuted: true });

                    alert("Your microphone has been disabled by an admin.");
                }
            }

            if (!perms.screen && isScreenSharing) {
                toggleScreenShare(false, socket); // Stop sharing immediately
                alert("Your screen share was stopped by an admin.");
            }
        }

        // --- GLOBAL: All Users Data (for Admin) ---
        let allUsers = [];
        const bufferedPrivateMessages = {}; // Stores history for unopened tabs

        async function main() {
            try {
                // Step 1: Get camera and mic access first.
                try {
                    localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                } catch (err) {
                    console.warn("Could not get camera + audio, trying audio only.", err);
                    localStream = await navigator.mediaDevices.getUserMedia({ video: false, audio: true });
                }
                localVideo.srcObject = localStream;
                addPinButton(document.getElementById('local-video-container'));

                // Initialize Audio Mixing with the Microphone stream
                setupAudioMixing(localStream);

                // Use the raw mic stream for the visualizer (still works)
                setupLocalSpeakingIndicator(localStream);

                // Step 2: Connect to the server.
                const token = localStorage.getItem('synapse-token');
                if (!token) { window.location.href = '/'; return; }
                const socket = io({
                    auth: { token: token }
                });

                // Utils
                window.escapeHtml = (unsafe) => {
                    return unsafe
                        .replace(/&/g, "&amp;")
                        .replace(/</g, "&lt;")
                        .replace(/>/g, "&gt;")
                        .replace(/"/g, "&quot;")
                        .replace(/'/g, "&#039;");
                };
                // Step 3: Set up all signaling listeners.
                socket.on('my-identity', (data) => {
                    myRole = data.role;
                    myPermissions = data.permissions;
                    window.myUsername = data.username; // Capture username
                    enforcePermissions(myPermissions, socket);

                    // --- ADMIN/SUPERUSER: Show Tabs ---
                    if (data.role === 'admin' || data.role === 'superuser') {
                        document.getElementById('tab-btn-system').style.display = 'inline-block';

                        // --- Error Message Handler ---
                        socket.on('error-message', (msg) => {
                            addChatMessage({ username: 'System', message: 'Error: ' + msg });
                        });

                        // --- Admin Action Success ---
                        socket.on('admin-action-success', (msg) => {
                            addChatMessage({ username: 'System', message: msg });
                            // Refresh the user list to show updated roles/permissions
                            socket.emit('get-all-users');
                        });
                    } else {
                        document.getElementById('tab-btn-system').style.display = 'none';
                    }

                    // Fetch for everyone (used for suggestions)
                    socket.emit('get-all-users');
                });

                socket.on('force-refresh', () => {
                    console.log("Admin forced refresh.");
                    window.location.reload();
                });

                // Listen for logs
                socket.on('server-logs', (logs) => {
                    const modal = document.getElementById('logs-modal');
                    const container = document.getElementById('logs-container');
                    const closeBtn = document.getElementById('logs-close-btn');
                    const refreshBtn = document.getElementById('logs-refresh-btn');
                    const clearBtn = document.getElementById('logs-clear-local-btn');

                    container.innerHTML = logs.map(l => {
                        const color = l.type === 'ERROR' ? 'red' : '#0f0';
                        return `<div style="color:${color}"><span style="color:#666">[${l.timestamp}]</span> [${l.type}] ${window.escapeHtml(l.msg)}</div>`;
                    }).join('');

                    // Scroll to bottom
                    container.scrollTop = container.scrollHeight;

                    // Use flex to center, assuming .modal-overlay uses flex centering
                    modal.style.display = 'flex';

                    closeBtn.onclick = () => modal.style.display = 'none';
                    window.onclick = (e) => { if (e.target === modal) modal.style.display = 'none'; };

                    refreshBtn.onclick = () => { socket.emit('chat message', '/logs'); }; // Re-trigger
                    clearBtn.onclick = () => { container.innerHTML = ''; };
                });

                socket.on('all-users-data', (data) => {
                    allUsers = data;
                });

                socket.on('permission-update', ({ feature, value }) => {
                    myPermissions[feature] = value;
                    enforcePermissions(myPermissions, socket);
                });

                socket.on('existing-users', (users) => {
                    for (const [socketId, userData] of Object.entries(users)) {
                        remoteUsers[socketId] = userData; // Track locally
                        createPeerConnection(socketId, true, userData, socket);
                    }
                });
                socket.on('user-joined', (socketId, userData) => {
                    remoteUsers[socketId] = userData; // Track locally

                    // --- NEW PROTECTION LOGIC ---
                    // Before adding the new user, check for and remove any "ghost" duplicates.
                    // This handles rapid reconnects where the 'user-left' event hasn't processed yet.
                    document.querySelectorAll('.video-container').forEach(container => {
                        const usernameDiv = container.querySelector('.username-overlay');
                        // If a container with the same username already exists (and isn't our own)
                        if (usernameDiv && usernameDiv.textContent === userData.username && container.id !== 'local-video-container') {
                            console.warn(`Duplicate user found for ${userData.username}. Cleaning up old connection.`);
                            const oldSocketId = container.id;

                            // Clean up all old resources associated with the ghost user
                            if (peerConnections[oldSocketId]) {
                                peerConnections[oldSocketId].close();
                                delete peerConnections[oldSocketId];
                            }
                            if (audioAnalyzers[oldSocketId]) {
                                cancelAnimationFrame(audioAnalyzers[oldSocketId].loopId);
                                delete audioAnalyzers[oldSocketId];
                            }
                            container.remove();
                        }
                    });
                    // --- END OF NEW LOGIC ---
                    // Now, create the connection for the new, legitimate user.
                    createPeerConnection(socketId, false, userData, socket);
                });
                socket.on('user-mute-status', (socketId, isMuted) => {
                    const container = document.getElementById(socketId);
                    if (container) setMuteIndicator(container, isMuted);
                });
                socket.on('webrtc-offer', (fromSocketId, offer) => { const pc = peerConnections[fromSocketId]; if (pc) { pc.setRemoteDescription(new RTCSessionDescription(offer)).then(() => pc.createAnswer()).then(answer => pc.setLocalDescription(answer)).then(() => socket.emit('webrtc-answer', fromSocketId, pc.localDescription)); } });
                socket.on('webrtc-answer', (fromSocketId, answer) => { const pc = peerConnections[fromSocketId]; if (pc) pc.setRemoteDescription(new RTCSessionDescription(answer)); });
                socket.on('webrtc-ice-candidate', (fromSocketId, candidate) => { const pc = peerConnections[fromSocketId]; if (pc) pc.addIceCandidate(new RTCIceCandidate(candidate)); });
                socket.on('user-left', (socketId) => {
                    // 1. Stop the audio analysis loop first to prevent errors
                    if (audioAnalyzers[socketId]) {
                        cancelAnimationFrame(audioAnalyzers[socketId].loopId);
                        delete audioAnalyzers[socketId];
                    }

                    // 2. Close the WebRTC connection
                    if (peerConnections[socketId]) {
                        peerConnections[socketId].close();
                        delete peerConnections[socketId];
                    }

                    // 3. Find and remove the video container from the screen
                    const containerToRemove = document.getElementById(socketId);
                    if (containerToRemove) {
                        // If the user who left was the one pinned, reset the layout
                        if (containerToRemove.classList.contains('pinned')) {
                            togglePin(containerToRemove); // This just unpins everyone
                        }
                        containerToRemove.remove();
                    }
                });

                // Step 4: Set up controls.
                const muteBtn = document.getElementById('mute-btn');
                muteBtn.addEventListener('click', () => {
                    // Permission Check
                    if (myPermissions && myPermissions.audio === false) {
                        return alert("Admin has successfully disabled your microphone.");
                    }

                    const audioTrack = localStream.getAudioTracks()[0];
                    if (audioTrack) {
                        audioTrack.enabled = !audioTrack.enabled;
                        const isMuted = !audioTrack.enabled;
                        muteBtn.textContent = isMuted ? 'Unmute Mic' : 'Mute Mic';
                        muteBtn.classList.toggle('active', isMuted);
                        setMuteIndicator(document.getElementById('local-video-container'), isMuted);
                        // This line tells everyone else you are muted
                        socket.emit('mute-status-changed', { isMuted });
                    }
                });

                const cameraBtn = document.getElementById('camera-btn');
                cameraBtn.addEventListener('click', () => {
                    if (isScreenSharing) return;
                    // Permission Check
                    if (myPermissions && myPermissions.video === false) {
                        return alert("Admin has successfully disabled your camera.");
                    }

                    const videoTrack = localStream.getVideoTracks()[0];
                    if (videoTrack) {
                        videoTrack.enabled = !videoTrack.enabled;
                        cameraBtn.textContent = videoTrack.enabled ? 'Turn Camera Off' : 'Turn Camera On';
                        cameraBtn.classList.toggle('active', !videoTrack.enabled);
                    }
                });

                // --- Chat Toggle Logic ---
                const chatContainer = document.getElementById('chat-container');
                const chatBtn = document.getElementById('chat-btn');
                const closeChatBtn = document.getElementById('close-chat-btn');

                function toggleChat() {
                    chatContainer.classList.toggle('hidden');
                    const isHidden = chatContainer.classList.contains('hidden');
                    chatBtn.classList.toggle('active', !isHidden);
                }

                chatBtn.addEventListener('click', toggleChat);
                closeChatBtn.addEventListener('click', toggleChat);

                document.getElementById('hangup-btn').addEventListener('click', () => { window.location.href = '/'; });

                // --- NEW LOGIC FOR SCREEN SHARE MODAL ---
                const qualityModal = document.getElementById('quality-modal');
                const standardQualityBtn = document.getElementById('standard-quality-btn');
                const hdQualityBtn = document.getElementById('hd-quality-btn');

                // The "Share Screen" button now opens the modal.
                document.getElementById('screen-share-btn').addEventListener('click', () => {
                    // Permission Check
                    if (!isScreenSharing && myPermissions && myPermissions.screen === false) {
                        return alert("Admin has successfully disabled your screen sharing.");
                    }

                    if (isScreenSharing) {
                        // If you're already sharing, just stop it.
                        toggleScreenShare(false, socket);
                    } else {
                        // Otherwise, show the quality options.
                        qualityModal.classList.add('visible');
                    }
                });

                // Listeners for the buttons inside the modal.
                standardQualityBtn.addEventListener('click', () => {
                    qualityModal.classList.remove('visible');
                    toggleScreenShare(false, socket); // isHD = false
                });

                hdQualityBtn.addEventListener('click', () => {
                    qualityModal.classList.remove('visible');
                    toggleScreenShare(true, socket); // isHD = true
                });

                // Hide the modal if the user clicks the background overlay.
                qualityModal.addEventListener('click', (e) => {
                    if (e.target === qualityModal) {
                        qualityModal.classList.remove('visible');
                    }
                });
                // Inside your main() function

                const messages = document.getElementById('messages');
                const chatForm = document.getElementById('chat-form');
                const chatInput = document.getElementById('chat-input');

                // --- CHAT HISTORY LOGIC ---
                // --- CHAT HISTORY LOGIC ---
                // Load from LocalStorage
                let myMessageHistory = [];
                try {
                    const rawHistory = JSON.parse(localStorage.getItem('chat_input_history') || '[]');
                    // Migration: Convert old strings to objects
                    myMessageHistory = rawHistory.map(item => {
                        if (typeof item === 'string') {
                            return { text: item, timestamp: Date.now() };
                        }
                        return item;
                    });
                } catch (e) { console.error("History parse error", e); }

                let historyLimit = 50;
                try {
                    const savedLimit = localStorage.getItem('chat_input_history_limit');
                    if (savedLimit) historyLimit = parseInt(savedLimit, 10);
                } catch (e) { }

                function saveInputHistory() {
                    // Limit to configured limit (unless -1 for infinite)
                    if (historyLimit !== -1 && myMessageHistory.length > historyLimit) {
                        myMessageHistory = myMessageHistory.slice(myMessageHistory.length - historyLimit);
                    }
                    localStorage.setItem('chat_input_history', JSON.stringify(myMessageHistory));
                }

                function openHistoryModal() {
                    const modal = document.getElementById('history-modal');
                    const list = document.getElementById('history-list');
                    const closeBtn = document.getElementById('history-close-btn');
                    const clearBtn = document.getElementById('history-clear-all-btn');
                    const limitInput = document.getElementById('history-limit-input');

                    limitInput.value = historyLimit;
                    limitInput.onchange = () => {
                        let newLimit = parseInt(limitInput.value, 10);
                        if (isNaN(newLimit)) newLimit = 50;
                        // Allow -1 for infinite, otherwise enforce positive
                        if (newLimit !== -1 && newLimit < 1) newLimit = 50;

                        historyLimit = newLimit;
                        localStorage.setItem('chat_input_history_limit', historyLimit);
                        // Re-trim and save immediately
                        saveInputHistory();
                        render();
                    };

                    function render() {
                        list.innerHTML = '';
                        if (myMessageHistory.length === 0) {
                            list.innerHTML = '<li style="padding:10px; color:#888; text-align:center;">No history.</li>';
                            return;
                        }

                        const reversedHistory = [...myMessageHistory]; // Actually, user wants last message at bottom -> Oldest First?
                        // "Last message go to bottom" implies normal chronological order (oldest top, newest bottom).
                        // Currently I was reversing it (newest top).
                        // So I should just iterate myMessageHistory directly.

                        myMessageHistory.forEach((item, index) => {
                            const li = document.createElement('li');
                            li.style.padding = '8px';
                            li.style.borderBottom = '1px solid #444';
                            li.style.display = 'flex';
                            li.style.justifyContent = 'space-between';
                            li.style.alignItems = 'center';

                            const span = document.createElement('span');
                            const timeStr = new Date(item.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                            span.textContent = `[${timeStr}] ${item.text}`;
                            span.style.wordBreak = 'break-all';
                            span.style.marginRight = '10px';

                            const delBtn = document.createElement('button');
                            delBtn.textContent = 'âœ–';
                            delBtn.style.padding = '2px 6px';
                            delBtn.style.background = 'none';
                            delBtn.style.border = 'none';
                            delBtn.style.color = '#d93025';
                            delBtn.style.cursor = 'pointer';
                            delBtn.style.fontSize = '1.2em';
                            delBtn.onclick = () => {
                                myMessageHistory.splice(index, 1);
                                saveInputHistory();
                                render();
                            };

                            li.appendChild(span);
                            li.appendChild(delBtn);
                            list.appendChild(li);
                        });

                        // Scroll to bottom
                        setTimeout(() => list.scrollTop = list.scrollHeight, 0);
                    }

                    render();
                    modal.classList.add('visible');

                    closeBtn.onclick = () => modal.classList.remove('visible');
                    clearBtn.onclick = () => {
                        if (confirm("Clear all local history?")) {
                            myMessageHistory = [];
                            saveInputHistory();
                            render();
                        }
                    };

                    modal.onclick = (e) => { if (e.target === modal) modal.classList.remove('visible'); };
                }

                let historyIndex = -1;
                let currentDraft = '';

                // --- COMMAND SUGGESTIONS LOGIC ---
                // --- COMMAND SUGGESTIONS LOGIC ---
                const AVAILABLE_COMMANDS = [
                    { cmd: '/clearhistory', role: 'all' },
                    { cmd: '/clear', role: 'admin' },
                    { cmd: '/roll', role: 'all' },

                    { cmd: '/admin', role: 'admin' },
                    { cmd: '/refresh', role: 'admin' },
                    { cmd: '/logs', role: 'admin' },
                    { cmd: '/message', role: 'all' },
                    { cmd: '/make', role: 'superuser' },
                    { cmd: '/myhistory', role: 'all' }
                ];
                const suggestionsContainer = document.getElementById('command-suggestions');
                let selectedSuggestionIndex = -1;

                function showSuggestions(query) {
                    suggestionsContainer.innerHTML = '';
                    selectedSuggestionIndex = -1;

                    if (!query || !query.startsWith('/')) {
                        suggestionsContainer.classList.remove('visible');
                        return;
                    }

                    // Filter commands based on role
                    // Superuser sees everything Admin sees
                    const matches = AVAILABLE_COMMANDS.filter(item => {
                        if (!item.cmd.startsWith(query)) return false;
                        if (item.role === 'admin' && (myRole !== 'admin' && myRole !== 'superuser')) return false;
                        return true;
                    });

                    // --- AUTOCOMPLETE FOR /admin ---
                    if (query.startsWith('/admin ')) {
                        const partial = query.substring(7);
                        // Filter allUsers
                        const userMatches = allUsers.filter(u => u.username.toLowerCase().startsWith(partial.toLowerCase()));

                        // Actually, if typing /admin space, only show users.
                        if (userMatches.length > 0) {
                            suggestionsContainer.innerHTML = ''; // Clear commands
                            userMatches.forEach(u => {
                                const div = document.createElement('div');
                                div.className = 'suggestion-item';
                                const status = u.isOnline ? ' <span style="color:#4caf50; font-size:0.8em">â— Online</span>' : ' <span style="color:#aaa; font-size:0.8em">â—‹ Offline</span>';
                                div.innerHTML = `/admin ${u.username}` + status;
                                div.onclick = () => selectSuggestion(`/admin ${u.username}`);
                                suggestionsContainer.appendChild(div);
                            });
                            suggestionsContainer.classList.add('visible');
                            return;
                        }
                    }

                    // --- AUTOCOMPLETE FOR /make ---
                    if (query.startsWith('/make ')) {
                        const afterMake = query.substring(6);
                        const parts = afterMake.split(' ');

                        // Case 1: Typing Username (parts[0] is being typed, no second part yet)
                        // Note: split(' ') on "foo" -> ["foo"]. on "foo " -> ["foo", ""]

                        if (parts.length === 1 && !afterMake.endsWith(' ')) {
                            const partialUser = parts[0].toLowerCase();
                            const userMatches = allUsers.filter(u => u.username.toLowerCase().startsWith(partialUser));

                            if (userMatches.length > 0) {
                                suggestionsContainer.innerHTML = '';
                                userMatches.forEach(u => {
                                    const div = document.createElement('div');
                                    div.className = 'suggestion-item';
                                    const status = u.isOnline ? ' <span style="color:#4caf50; font-size:0.8em">â— Online</span>' : ' <span style="color:#aaa; font-size:0.8em">â—‹ Offline</span>';
                                    div.innerHTML = `/make ${u.username}` + status;
                                    div.onclick = () => {
                                        chatInput.value = `/make ${u.username} `;
                                        chatInput.focus();
                                        showSuggestions(chatInput.value); // Trigger next step
                                    };
                                    suggestionsContainer.appendChild(div);
                                });
                                suggestionsContainer.classList.add('visible');
                                return;
                            }
                        }

                        // Case 2: Username completed (space exists), typing role
                        if (parts.length >= 2 || (parts.length === 1 && afterMake.endsWith(' '))) {
                            const targetName = parts[0];
                            const partialRole = (parts[1] || '').toLowerCase();

                            const targetUser = allUsers.find(u => u.username === targetName);
                            if (targetUser) {
                                suggestionsContainer.innerHTML = '';
                                const currentRole = targetUser.role || 'user';

                                ['admin', 'user'].forEach(role => {
                                    if (role.startsWith(partialRole)) {
                                        const div = document.createElement('div');
                                        div.className = 'suggestion-item';
                                        // Show role + context
                                        div.innerHTML = `/make ${targetName} <strong>${role}</strong> <span style='color:#aaa; font-size:0.85em'> (Current: ${currentRole})</span>`;
                                        div.onclick = () => selectSuggestion(`/make ${targetName} ${role}`);
                                        suggestionsContainer.appendChild(div);
                                    }
                                });

                                if (suggestionsContainer.children.length > 0) {
                                    suggestionsContainer.classList.add('visible');
                                    return;
                                }
                            }
                        }
                    }

                    // --- /message auto-complete ---
                    if (query.startsWith('/message ')) {
                        const afterCmd = query.substring(9); // remove "/message "
                        const parts = afterCmd.split(' ');

                        // Case 1: Typing Username
                        if (parts.length === 1 && !afterCmd.endsWith(' ')) {
                            const partialUser = parts[0].toLowerCase();

                            // Filter: Name matches AND (if normal user, must be online)
                            const userMatches = allUsers.filter(u => {
                                if (!u.username.toLowerCase().startsWith(partialUser)) return false;
                                if ((myRole !== 'admin' && myRole !== 'superuser') && !u.isOnline) return false;
                                return true;
                            });

                            if (userMatches.length > 0) {
                                suggestionsContainer.innerHTML = '';
                                userMatches.forEach(u => {
                                    const div = document.createElement('div');
                                    div.className = 'suggestion-item';

                                    const status = u.isOnline ? ' <span style="color:#4caf50; font-size:0.8em">â— Online</span>' : ' <span style="color:#aaa; font-size:0.8em">â—‹ Offline</span>';
                                    div.innerHTML = `/message ${u.username}` + status;

                                    div.onclick = () => {
                                        const nextVal = `/message ${u.username} `;
                                        chatInput.value = nextVal;
                                        chatInput.focus();
                                        // hide suggestions or show nothing?
                                        suggestionsContainer.classList.remove('visible');
                                        // Maybe trigger suggestions again?
                                        showSuggestions(nextVal);
                                    };
                                    suggestionsContainer.appendChild(div);
                                });
                                suggestionsContainer.classList.add('visible');
                                return;
                            }
                        }
                    }

                    if (matches.length === 0) {
                        suggestionsContainer.classList.remove('visible');
                        return;
                    }

                    matches.forEach((item, index) => {
                        const div = document.createElement('div');
                        div.className = 'suggestion-item';
                        div.textContent = item.cmd;
                        div.onclick = () => selectSuggestion(item.cmd);
                        suggestionsContainer.appendChild(div);
                    });

                    suggestionsContainer.classList.add('visible');
                }

                function selectSuggestion(cmd) {
                    chatInput.value = cmd + ' ';
                    suggestionsContainer.classList.remove('visible');
                    chatInput.focus();
                    // Trigger input event manually so suggestions update for the *next* part (e.g. username)
                    showSuggestions(chatInput.value);
                }

                function updateSuggestionSelection(direction) {
                    const items = suggestionsContainer.querySelectorAll('.suggestion-item');
                    if (items.length === 0) return;

                    if (selectedSuggestionIndex >= 0) {
                        items[selectedSuggestionIndex].classList.remove('selected');
                    }

                    if (direction === 'up') {
                        selectedSuggestionIndex = selectedSuggestionIndex > 0 ? selectedSuggestionIndex - 1 : items.length - 1;
                    } else {
                        selectedSuggestionIndex = selectedSuggestionIndex < items.length - 1 ? selectedSuggestionIndex + 1 : 0;
                    }

                    items[selectedSuggestionIndex].classList.add('selected');
                    items[selectedSuggestionIndex].scrollIntoView({ block: 'nearest' });
                }

                chatInput.addEventListener('input', (e) => {
                    const val = chatInput.value;
                    showSuggestions(val);
                });

                chatForm.addEventListener('submit', function (e) {
                    e.preventDefault();
                    console.log("Form submit triggered with value:", chatInput.value);

                    try {
                        // Aggressive cleanup
                        suggestionsContainer.classList.remove('visible');
                        suggestionsContainer.innerHTML = '';
                        selectedSuggestionIndex = -1;

                        if (chatInput.value) {
                            const msg = chatInput.value;

                            // --- LOCAL COMMAND: Clear History ---
                            if (msg.trim() === '/clearhistory') {
                                myMessageHistory = []; // Clear array
                                saveInputHistory();
                                historyIndex = -1;
                                addChatMessage({ username: 'System', message: 'Local typing history cleared.' });
                                chatInput.value = '';
                                return;
                            }

                            // --- LOCAL COMMAND: /myhistory ---
                            if (msg.trim() === '/myhistory') {
                                myMessageHistory.push({ text: msg, timestamp: Date.now() });
                                saveInputHistory();
                                historyIndex = -1;
                                openHistoryModal();
                                chatInput.value = '';
                                return;
                            }

                            // --- PRIVATE MESSAGE COMMAND: /message <user> [text] ---
                            if (msg.startsWith('/message ')) {
                                const parts = msg.trim().split(/\s+/);
                                if (parts.length < 2) {
                                    addChatMessage({ username: 'System', message: 'Usage: /message <username> [text]' });
                                    chatInput.value = '';
                                    return;
                                }
                                const targetUser = parts[1];

                                // Always open tab
                                createTab(targetUser, true);

                                // If text provided, send it
                                if (parts.length >= 3) {
                                    const text = parts.slice(2).join(' ');
                                    socket.emit('private message', { to: targetUser, message: text });
                                }

                                chatInput.value = '';
                                return;
                            }

                            // --- ADMIN COMMAND: /admin [username] ---
                            if (msg.startsWith('/admin')) {
                                if (myRole !== 'admin' && myRole !== 'superuser') {
                                    addChatMessage({ username: 'System', message: 'Unauthorized: Admin only.' });
                                    chatInput.value = '';
                                    return;
                                }

                                const parts = msg.trim().split(' ');

                                // Case 1: Just "/admin"
                                if (parts.length === 1) {
                                    myMessageHistory.push({ text: msg, timestamp: Date.now() });
                                    saveInputHistory();
                                    historyIndex = -1;
                                    openUserListModal(socket);
                                    chatInput.value = '';
                                    return;
                                }

                                // Case 2: "/admin [username]"
                                const targetUsername = msg.substring(7).trim();
                                if (!targetUsername) {
                                    // Fallback just in case split logic is weird
                                    myMessageHistory.push({ text: msg, timestamp: Date.now() });
                                    saveInputHistory();
                                    historyIndex = -1;
                                    openUserListModal(socket);
                                    chatInput.value = '';
                                    return;
                                }

                                myMessageHistory.push({ text: msg, timestamp: Date.now() });
                                saveInputHistory();
                                historyIndex = -1;

                                // Find in allUsers
                                const userObj = allUsers.find(u => u.username === targetUsername);

                                if (userObj) {
                                    openAdminModal(userObj, socket); // Pass object, not socket ID
                                    addChatMessage({ username: 'System', message: `Opened controls for ${targetUsername}` });
                                } else {
                                    addChatMessage({ username: 'System', message: `User "${targetUsername}" not found in database.` });
                                }

                                chatInput.value = '';
                                return;
                            }

                            // --- SUPERUSER COMMAND: /make [username] [role] ---
                            if (msg.startsWith('/make ')) {
                                if (myRole !== 'superuser') {
                                    addChatMessage({ username: 'System', message: 'Unauthorized: Superuser only.' });
                                    chatInput.value = '';
                                    return;
                                }

                                const parts = msg.trim().split(' ');
                                if (parts.length < 3) {
                                    addChatMessage({ username: 'System', message: 'Usage: /make <username> <role> (admin|user)' });
                                    chatInput.value = '';
                                    return;
                                }

                                const targetUsername = parts[1];
                                const newRole = parts[2];

                                if (newRole !== 'admin' && newRole !== 'user') {
                                    addChatMessage({ username: 'System', message: 'Invalid role. Use "admin" or "user".' });
                                    chatInput.value = '';
                                    return;
                                }

                                myMessageHistory.push({ text: msg, timestamp: Date.now() });
                                saveInputHistory();
                                historyIndex = -1;

                                socket.emit('superuser-change-role', { targetUsername, newRole });
                                addChatMessage({ username: 'System', message: `Requesting to make ${targetUsername} a ${newRole}...` });
                                chatInput.value = '';
                                return;
                            }

                            // --- IMPLICIT PRIVATE MESSAGE (If tab active) ---
                            if (activeTab !== 'public' && activeTab !== 'system') {
                                socket.emit('private message', { to: activeTab, message: msg });
                                chatInput.value = '';
                                // Add to history if unique or just always add? Terminal usually adds always
                                // Only add if not empty (already checked)
                                myMessageHistory.push({ text: msg, timestamp: Date.now() });
                                saveInputHistory();
                                historyIndex = -1; // Reset index on send
                                return;
                            }


                            // --- LOCAL CHAT (System Tab) SCRATCHPAD ---
                            if (activeTab === 'system') {
                                addChatMessage({ username: 'Note', message: msg }); // Local only
                                myMessageHistory.push({ text: msg, timestamp: Date.now() });
                                saveInputHistory();
                                chatInput.value = '';
                                return;
                            }

                            // --- PUBLIC CHAT ---
                            socket.emit('chat message', msg);

                            // Add to history if unique or just always add? Terminal usually adds always
                            // Only add if not empty (already checked)
                            myMessageHistory.push({ text: msg, timestamp: Date.now() });
                            saveInputHistory();
                            chatInput.value = '';
                        }
                    } catch (err) {
                        console.error("Error in chat submit:", err);
                        addChatMessage({ username: 'System', message: 'Error processing command: ' + err.message });
                    }
                });

                chatInput.addEventListener('keydown', (e) => {
                    // Check if suggestions are visible
                    if (suggestionsContainer.classList.contains('visible')) {
                        if (e.key === 'ArrowUp') {
                            e.preventDefault();
                            updateSuggestionSelection('up');
                            return;
                        } else if (e.key === 'ArrowDown') {
                            e.preventDefault();
                            updateSuggestionSelection('down');
                            return;
                        } else if (e.key === 'Enter' || e.key === 'Tab') {
                            console.log("Keydown Enter/Tab. Index:", selectedSuggestionIndex);
                            if (selectedSuggestionIndex !== -1) {
                                e.preventDefault();
                                const items = suggestionsContainer.querySelectorAll('.suggestion-item');
                                if (items[selectedSuggestionIndex]) items[selectedSuggestionIndex].click();
                            } else if (e.key === 'Tab') {
                                // If tab pressed without selection, select first? Or just allow default tab? 
                                // Let's select first match if tab is pressed
                                e.preventDefault();
                                const items = suggestionsContainer.querySelectorAll('.suggestion-item');
                                if (items.length > 0) items[0].click();
                            }
                            return;
                        } else if (e.key === 'Escape') {
                            suggestionsContainer.classList.remove('visible');
                            return;
                        }
                    }

                    if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        if (myMessageHistory.length === 0) return;

                        if (historyIndex === -1) {
                            // First time pressing up, go to last message
                            currentDraft = chatInput.value; // Save current input
                            historyIndex = myMessageHistory.length - 1;
                        } else if (historyIndex > 0) {
                            // Go back one more
                            historyIndex--;
                        }

                        const item = myMessageHistory[historyIndex];
                        chatInput.value = (typeof item === 'object' && item.text) ? item.text : item;

                    } else if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        if (historyIndex === -1) return; // Already at present

                        if (historyIndex < myMessageHistory.length - 1) {
                            // Go forward one
                            historyIndex++;
                            const item = myMessageHistory[historyIndex];
                            chatInput.value = (typeof item === 'object' && item.text) ? item.text : item;
                        } else {
                            // Back to present
                            historyIndex = -1;
                            chatInput.value = currentDraft; // Restore saved draft
                        }
                    }
                });

                // In private/call.html

                function addChatMessage({ username, message, timestamp, recipient, isSelf }, logToConsole = true, bufferIfNoTab = false) {
                    const item = document.createElement('li');

                    // TIMESTAMP LOGIC
                    let timeStr = '';
                    if (timestamp) {
                        timeStr = new Date(timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    } else {
                        timeStr = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    }

                    // XSS FIX: Create a text node/element first to sanitize the input
                    // We don't want to run replace() on raw HTML string if it contains scripts.
                    const tempDiv = document.createElement('div');
                    tempDiv.textContent = message;
                    const sanitizedMessage = tempDiv.textContent;

                    // Regular expression to find URLs in the message text
                    const urlRegex = /(\b(https?|ftp|file):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])|(\bwww\.[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig;

                    // Replace found URLs with clickable <a> tags
                    // Since we are running this on the sanitized text, it is safe-ish, 
                    // but we must be careful not to re-introduce HTML manually without encoding.
                    // The safest way is to split by URL and append nodes.
                    // For simplicity in this codebase, we will stick to innerHTML 
                    // BUT ONLY with the sanitized base string where < > are already escaped? 
                    // No, textContent doesn't escape for us if we read it back.
                    // Actually, let's just use a safer approach:

                    const messageContent = document.createElement('span');

                    // Split text by URLs and append text nodes or anchor tags
                    const parts = sanitizedMessage.split(urlRegex);
                    // The split with capturing groups is tricky.
                    // Let's use a simpler approach: Just textContent the username, then innerHTML the linked message
                    // but we need to ESCAPE the message first.

                    // escapeHtml is now global


                    const safeMessage = escapeHtml(message);
                    const processedMessage = safeMessage.replace(urlRegex, (url) => {
                        let href = url;
                        if (!href.startsWith('http')) {
                            href = `http://${href}`;
                        }
                        return `<a href="${href}" target="_blank" rel="noopener noreferrer">${url}</a>`;
                    });

                    // --- TABBED CHAT LOGIC ---

                    let targetList = null;
                    const isSystem = username === 'System';

                    // 1. Determine Target Tab
                    if (isSystem) {
                        if (message.startsWith('Unauthorized') || message.startsWith('Usage') || message.startsWith('Invalid')) {
                            // Command responses
                            // If we are in public, show in public messages list (which is #messages)
                            // If we are in system, show in system
                            // If in private, show in that private tab?
                            if (activeTab === 'public') targetList = document.getElementById('messages');
                            else if (activeTab === 'system') targetList = document.getElementById('system-messages');
                            else {
                                // Private tab active
                                const hiddenContainer = document.getElementById(`messages-${activeTab}`);
                                targetList = hiddenContainer || document.getElementById('messages');
                            }
                        } else {
                            // System Logs -> Local Tab (system-messages)
                            targetList = document.getElementById('system-messages');
                        }
                    } else if (recipient) {
                        // PRIVATE MESSAGE
                        const otherUser = isSelf ? recipient : username;

                        // Create tab if needed
                        // Create tab if needed
                        let tabBtn = document.querySelector(`.chat-tab[data-tab="${otherUser}"]`);

                        // BUFFERING LOGIC for Private History
                        if (!tabBtn && bufferIfNoTab) {
                            if (!bufferedPrivateMessages[otherUser]) bufferedPrivateMessages[otherUser] = [];
                            bufferedPrivateMessages[otherUser].push({ username, message, timestamp, recipient, isSelf });
                            return; // Do not create tab, do not display yet
                        }

                        if (!tabBtn) {
                            createTab(otherUser);
                        }

                        // Get container
                        let container = document.getElementById(`messages-${otherUser}`);
                        if (!container) {
                            createTab(otherUser);
                            container = document.getElementById(`messages-${otherUser}`);
                        }
                        targetList = container;

                        if (activeTab !== otherUser) {
                            tabBtn = document.querySelector(`.chat-tab[data-tab="${otherUser}"]`);
                            if (tabBtn) tabBtn.classList.add('unread');
                        }

                    } else {
                        // PUBLIC MESSAGE
                        targetList = document.getElementById('messages');

                        if (activeTab !== 'public') {
                            document.querySelector(`.chat-tab[data-tab="public"]`).classList.add('unread');
                        }
                    }

                    // Fallback
                    if (!targetList) targetList = document.getElementById('messages');


                    // DATE SEPARATOR LOGIC (Scoped to target list)
                    const messageDate = timestamp ? new Date(timestamp) : new Date();
                    const dateStr = messageDate.toLocaleDateString(undefined, { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });

                    if (!targetList.lastDate || targetList.lastDate !== dateStr) {
                        const sep = document.createElement('div');
                        sep.style.textAlign = 'center';
                        sep.style.fontSize = '0.85em';
                        sep.style.color = '#666';
                        sep.style.margin = '10px 0';
                        sep.style.position = 'relative';
                        sep.innerHTML = `<span style="position:relative; z-index:1;">${dateStr}</span>`;
                        targetList.appendChild(sep);
                        targetList.lastDate = dateStr;
                    }

                    item.innerHTML = `<span style="font-size:0.75em; color:#888;">[${timeStr}]</span> <strong>${escapeHtml(username)}:</strong> ${processedMessage}`;

                    targetList.appendChild(item);
                    targetList.scrollTop = targetList.scrollHeight;
                }

                // --- TAB MANAGEMENT ---
                let activeTab = 'public'; // 'public', 'system', or username

                function switchTab(tabName) {
                    activeTab = tabName;

                    // Update Buttons
                    document.querySelectorAll('.chat-tab').forEach(btn => {
                        if (btn.dataset.tab === tabName) {
                            btn.classList.add('active');
                            btn.classList.remove('unread');
                        } else {
                            btn.classList.remove('active');
                        }
                    });

                    // Update Containers
                    // Hide all first
                    document.querySelectorAll('.message-list').forEach(ul => ul.style.display = 'none');

                    if (tabName === 'public') {
                        document.getElementById('messages').style.display = 'block';
                        document.getElementById('messages').scrollTop = document.getElementById('messages').scrollHeight;
                    } else if (tabName === 'system') {
                        document.getElementById('system-messages').style.display = 'block';
                        document.getElementById('system-messages').scrollTop = document.getElementById('system-messages').scrollHeight;
                    } else {
                        // Private tab
                        const container = document.getElementById(`messages-${tabName}`);
                        if (container) {
                            container.style.display = 'block';
                            container.scrollTop = container.scrollHeight;
                        }
                    }

                    chatInput.focus();
                }
                // Expose to window for HTML onclick handlers
                window.switchTab = switchTab;


                function createTab(username, switchToIt = false) {
                    if (document.querySelector(`.chat-tab[data-tab="${username}"]`)) {
                        if (switchToIt) switchTab(username);
                        return; // Already exists
                    }
                    // ... rest of function ...


                    const tabsContainer = document.getElementById('chat-tabs');
                    const btn = document.createElement('button');
                    btn.className = 'chat-tab';
                    btn.dataset.tab = username;
                    btn.innerHTML = `${escapeHtml(username)} <span class="close-tab" onclick="closeTab(event, '${username}')">Ã—</span>`;
                    btn.onclick = (e) => {
                        if (e.target.classList.contains('close-tab')) return;
                        switchTab(username);
                    };
                    tabsContainer.appendChild(btn);

                    // Create Container
                    const messagesArea = document.getElementById('chat-messages-area');
                    const ul = document.createElement('ul');
                    ul.id = `messages-${username}`;
                    ul.className = 'message-list';
                    ul.style.display = 'none';
                    ul.style.flex = '1';
                    ul.style.overflowY = 'auto';
                    ul.style.padding = '1rem';
                    ul.style.margin = '0';
                    ul.style.listStyle = 'none';
                    messagesArea.appendChild(ul);

                    if (switchToIt) switchTab(username);

                    // REPLAY BUFFERED MESSAGES
                    if (bufferedPrivateMessages[username]) {
                        bufferedPrivateMessages[username].forEach(msgData => {
                            // Recursively call addChatMessage, ensuring we don't buffer again
                            addChatMessage(msgData, false, false);
                        });
                        delete bufferedPrivateMessages[username];
                    }
                }

                window.createTab = createTab;

                function closeTab(e, username) {
                    e.stopPropagation();
                    const btn = document.querySelector(`.chat-tab[data-tab="${username}"]`);
                    const container = document.getElementById(`messages-${username}`);

                    if (btn) btn.remove();
                    if (container) container.remove();

                    if (activeTab === username) {
                        switchTab('public');
                    }
                }
                window.closeTab = closeTab;


                socket.on('chat history', function (history) {
                    // Reset on full history load? Or just append?
                    // History is loaded once on connect.
                    // Clear existing messages in public and system tabs before loading history
                    document.getElementById('messages').innerHTML = '';
                    document.getElementById('system-messages').innerHTML = '';
                    document.getElementById('messages').lastDate = null;
                    document.getElementById('system-messages').lastDate = null;

                    history.forEach(msg => {
                        // Compatibility shim if history item structure varies
                        if (!msg.username) return;
                        addChatMessage(msg, false, true);
                    });
                });

                socket.on('chat message', function (msg) {
                    addChatMessage(msg);
                });

                socket.on('private message', function (msg) {
                    addChatMessage(msg);
                });

                socket.on('chat cleared', function () {
                    const messages = document.getElementById('messages');
                    messages.innerHTML = '';
                    messages.lastDate = null; // Reset date tracking
                });

            } catch (err) {
                console.error("Fatal Error:", err);
                document.body.innerHTML = `<div style="text-align: center; padding-top: 50px;"><h1>Error</h1><p>Could not access camera/microphone. Please grant permission and refresh.</p></div>`;
            }
        }
        // Add these icon variables at the top of your script
        const speakerIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>`;
        const speakerOffIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 5L6 9H2v6h4l5 4V5z"></path><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line></svg>`;
        // This is the new function to add the separate mute buttons
        // This is the new function to add the separate mute buttons
        function addClientMuteControls(videoContainer, socket) {
            const controlsContainer = document.createElement('div');
            controlsContainer.className = 'client-controls';

            // Button to mute the user's voice (mic)
            const muteVoiceBtn = document.createElement('button');
            muteVoiceBtn.innerHTML = speakerIcon;
            muteVoiceBtn.title = 'Mute Voice';
            muteVoiceBtn.onclick = (e) => {
                e.stopPropagation();
                const socketId = videoContainer.id;
                const gainNode = remoteGainNodes[socketId];
                if (gainNode) {
                    // Toggle gain between 0 (muted) and 1 (unmuted)
                    const isMuted = gainNode.gain.value === 0;
                    gainNode.gain.value = isMuted ? 1 : 0;
                    muteVoiceBtn.innerHTML = isMuted ? speakerOffIcon : speakerIcon;
                } else {
                    muteVoiceBtn.innerHTML = speakerOffIcon;
                }
            };

            // Button to mute the stream's audio (screen share audio)
            const muteStreamBtn = document.createElement('button');
            muteStreamBtn.innerHTML = speakerIcon;
            muteStreamBtn.title = 'Mute Stream';
            muteStreamBtn.onclick = (e) => {
                e.stopPropagation();
                const videoEl = videoContainer.querySelector('video');
                if (videoEl) {
                    videoEl.muted = !videoEl.muted;
                    muteStreamBtn.innerHTML = videoEl.muted ? speakerOffIcon : speakerIcon;
                }
            };

            controlsContainer.appendChild(muteVoiceBtn);
            controlsContainer.appendChild(muteStreamBtn);

            // --- ADMIN CONTROLS ---
            if (myRole === 'admin' || myRole === 'superuser') {
                const adminBtn = document.createElement('button');
                adminBtn.innerText = 'âš™';
                adminBtn.title = 'Manage User';
                adminBtn.onclick = (e) => {
                    e.stopPropagation();
                    openAdminModal(videoContainer.id, socket);
                };
                controlsContainer.appendChild(adminBtn);
            }

            videoContainer.appendChild(controlsContainer);
        }

        // --- ADMIN USER LIST GUI ---
        function openUserListModal(socket) {
            const listModal = document.getElementById('admin-user-list-modal');
            const onlineList = document.getElementById('admin-user-list-online');
            const offlineList = document.getElementById('admin-user-list-offline');

            onlineList.innerHTML = '';
            offlineList.innerHTML = '';

            // Sort logic: A-Z
            const sortedUsers = [...allUsers].sort((a, b) => a.username.localeCompare(b.username));

            sortedUsers.forEach(user => {
                const li = document.createElement('li');
                li.textContent = user.username;
                li.onclick = () => {
                    listModal.classList.remove('visible');
                    openAdminModal(user, socket);
                };

                if (user.isOnline) {
                    onlineList.appendChild(li);
                } else {
                    offlineList.appendChild(li);
                }
            });

            listModal.classList.add('visible');

            const closeBtn = document.getElementById('admin-user-list-close-btn');
            closeBtn.onclick = () => listModal.classList.remove('visible');

            listModal.onclick = (e) => {
                if (e.target === listModal) listModal.classList.remove('visible');
            };
        }

        // --- ADMIN MODAL LOGIC (REFACTORED) ---
        function openAdminModal(targetUserOrId, socket) {
            let user;
            // It might be a socketId (click on video) or a user object (from /admin command)
            if (typeof targetUserOrId === 'string') {
                // It's a socketId from the video container
                user = remoteUsers[targetUserOrId];
            } else {
                // It's a user object from allUsers
                user = targetUserOrId;
            }

            if (!user) return;

            const modal = document.getElementById('admin-modal');
            const title = document.getElementById('admin-modal-title');
            title.innerText = `Manage ${user.username}` + (user.isOnline === false ? ' (Offline)' : '');

            const pChat = document.getElementById('perm-chat');
            const pVideo = document.getElementById('perm-video');
            const pAudio = document.getElementById('perm-audio');
            const pScreen = document.getElementById('perm-screen');

            // Set current state (default to true if missing)
            const perms = user.permissions || { chat: true, video: true, audio: true, screen: true };
            pChat.checked = perms.chat !== false;
            pVideo.checked = perms.video !== false;
            pAudio.checked = perms.audio !== false;
            pScreen.checked = perms.screen !== false;

            // CLIENT SAFEGUARD: Logic for UI state

            const isSelf = (user.username === window.myUsername);
            const targetRole = user.role || 'user'; // We need to make sure we have role. 'allUsers' has it. 'remoteUsers' needs it.

            // Reset Disabled State first
            [pChat, pVideo, pAudio, pScreen].forEach(el => el.disabled = false);
            title.innerText = `Manage ${user.username}` + (user.isOnline === false ? ' (Offline)' : '');

            // 1. SELF MANAGEMENT
            if (isSelf) {
                title.innerText += " (You)";
                // Allow Video/Audio/Screen.
                // EXPLICITLY DISABLE CHAT to prevent lockout.
                pChat.disabled = true;
                pChat.parentElement.title = "You cannot disable your own chat.";
            }

            // 2. ADMIN managing SUPERUSER
            if (myRole === 'admin' && targetRole === 'superuser') {
                // Admin can manage Video/Audio/Screen of Superuser
                // BUT CANNOT Disable Chat
                pChat.disabled = true;
                pChat.parentElement.title = "Admins cannot disable chat for Superusers.";
            }

            // 3. ADMIN managing ADMIN (Same rule applies based on server logic? "Privileged users")
            // Server said: "Admins cannot disable chat for other privileged users (role=admin or role=superuser)"
            // So let's match that.
            if (myRole === 'admin' && targetRole === 'admin' && !isSelf) {
                pChat.disabled = true;
                pChat.parentElement.title = "Admins cannot disable chat for other Admins.";
            }

            // Update Handler
            function updatePerm(feature, value) {
                // Optimistic UI update? Or wait? 
                // Let's just emit.
                socket.emit('admin-update-permission', { targetUsername: user.username, feature, value });
            }

            pChat.onclick = () => updatePerm('chat', pChat.checked);
            pVideo.onclick = () => updatePerm('video', pVideo.checked);
            pAudio.onclick = () => updatePerm('audio', pAudio.checked);
            pScreen.onclick = () => updatePerm('screen', pScreen.checked);

            // --- SUPERUSER: Change Role Section ---
            const roleSection = document.getElementById('superuser-role-section');
            if (myRole === 'superuser') {
                roleSection.style.display = 'block';
                const roleSelect = document.getElementById('role-select');

                // Set current role value logic
                // If it's superuser, maybe show it but disable it? Or just default to admin?
                // The dropdown only has Admin/User.
                if (user.role === 'superuser') {
                    // If target is superuser, maybe don't allow demoting via this simple dropdown easily?
                    // Or just set value to something?
                    // Let's just handle admin/user for now.
                    roleSelect.value = 'admin'; // Fallback
                } else {
                    roleSelect.value = (user.role === 'admin') ? 'admin' : 'user';
                }

                roleSelect.onchange = () => {
                    const newRole = roleSelect.value;
                    socket.emit('superuser-change-role', { targetUsername: user.username, newRole });
                };
            } else {
                roleSection.style.display = 'none';
            }

            // --- SUPERUSER: Change Password Section ---
            const passwordSection = document.getElementById('superuser-password-section');
            if (myRole === 'superuser') {
                passwordSection.style.display = 'block';
                const newPassInput = document.getElementById('new-password-input');
                const updatePassBtn = document.getElementById('update-password-btn');

                updatePassBtn.onclick = () => {
                    const newPass = newPassInput.value;
                    if (newPass) {
                        socket.emit('superuser-change-password', { targetUsername: user.username, newPassword: newPass });
                        newPassInput.value = ''; // clear after send
                    }
                };
            } else {
                passwordSection.style.display = 'none';
            }

            modal.classList.add('visible');

            // Close logic
            const closeBtn = document.getElementById('admin-close-btn');
            closeBtn.onclick = () => modal.classList.remove('visible');

            // Click outside
            modal.onclick = (e) => { if (e.target === modal) modal.classList.remove('visible'); };
        }

        async function createPeerConnection(socketId, isInitiator, userData, socket) {
            // Fetch ICE servers from our own backend to fix network issues
            let iceServers = [{ urls: 'stun:stun.l.google.com:19302' }]; // Fallback
            try {
                const response = await fetch('/api/ice-config');
                if (response.ok) {
                    iceServers = await response.json();
                }
            } catch (e) {
                console.error("Failed to fetch ICE config, using default STUN", e);
            }

            const pc = new RTCPeerConnection({ iceServers });
            peerConnections[socketId] = pc;

            // --- WebRTC Connection Monitoring & Logging ---
            console.log(`[WebRTC] Creating connection to ${userData.username} (initiator: ${isInitiator})`);

            // Check if TURN is configured
            const hasTurn = iceServers.some(s => s.urls && (Array.isArray(s.urls) ? s.urls.some(u => u.includes('turn:')) : s.urls.includes('turn:')));
            if (!hasTurn) {
                console.warn(`[WebRTC] âš ï¸ No TURN server configured - users behind firewalls may not connect`);
            }

            // Monitor connection state changes
            pc.onconnectionstatechange = () => {
                console.log(`[WebRTC] ${userData.username} connection state: ${pc.connectionState}`);

                if (pc.connectionState === 'connected') {
                    console.log(`[WebRTC] âœ… Successfully connected to ${userData.username}`);
                } else if (pc.connectionState === 'failed') {
                    console.error(`[WebRTC] âŒ Connection to ${userData.username} FAILED`);
                    console.error(`[WebRTC] Possible reasons: firewall blocking, no TURN server, network issues`);

                    // Show error to user
                    addChatMessage({
                        username: 'System',
                        message: `âš ï¸ Cannot connect to ${userData.username}. They may be behind a firewall.`
                    });
                } else if (pc.connectionState === 'disconnected') {
                    console.warn(`[WebRTC] âš ï¸ Disconnected from ${userData.username}`);
                }
            };

            // Monitor ICE connection state
            pc.oniceconnectionstatechange = () => {
                console.log(`[WebRTC] ${userData.username} ICE state: ${pc.iceConnectionState}`);

                if (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed') {
                    console.log(`[WebRTC] âœ… ICE connection established with ${userData.username}`);
                } else if (pc.iceConnectionState === 'failed') {
                    console.error(`[WebRTC] âŒ ICE connection to ${userData.username} FAILED`);
                    if (!hasTurn) {
                        console.error(`[WebRTC] âš ï¸ NO TURN SERVER - This is likely why the connection failed`);
                        console.error(`[WebRTC] Solution: Configure TURN server in .env file`);
                    } else {
                        console.error(`[WebRTC] TURN is configured but connection still failed`);
                        console.error(`[WebRTC] Possible reasons: both users behind symmetric NAT, network blocking UDP`);
                    }
                } else if (pc.iceConnectionState === 'checking') {
                    console.log(`[WebRTC] ðŸ” Checking ICE candidates for ${userData.username}...`);
                }
            };

            // Monitor ICE gathering
            pc.onicegatheringstatechange = () => {
                console.log(`[WebRTC] ${userData.username} ICE gathering: ${pc.iceGatheringState}`);
            };

            // Log ICE candidates with type detection
            const originalIceCandidateHandler = pc.onicecandidate;
            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    const candidate = event.candidate.candidate;

                    // Detect candidate type
                    if (candidate.includes('typ host')) {
                        console.log(`[WebRTC] ${userData.username} - Local candidate (typ host)`);
                    } else if (candidate.includes('typ srflx')) {
                        console.log(`[WebRTC] ${userData.username} - Public IP candidate (typ srflx) via STUN`);
                    } else if (candidate.includes('typ relay')) {
                        console.log(`[WebRTC] ${userData.username} - âœ… TURN relay candidate (typ relay) - TURN working!`);
                    }

                    socket.emit('webrtc-ice-candidate', socketId, event.candidate);
                } else {
                    console.log(`[WebRTC] ${userData.username} - ICE gathering complete`);
                }
            };

            // --- Sending logic UPDATED for Audio Mixing ---
            // 1. Add the VIDEO track (either Camera or Screen)
            const videoStream = isScreenSharing ? screenStream : localStream;
            videoStream.getVideoTracks().forEach(track => pc.addTrack(track, videoStream));

            // 2. Add the MIXED AUDIO track (Always the same track!)
            if (mixedAudioStream && mixedAudioStream.getAudioTracks().length > 0) {
                const mixedTrack = mixedAudioStream.getAudioTracks()[0];
                pc.addTrack(mixedTrack, mixedAudioStream);
            }

            // --- THIS IS THE CORRECTED RECEIVING LOGIC ---
            pc.ontrack = (event) => {
                let videoContainer = document.getElementById(socketId);
                if (!videoContainer) {
                    videoContainer = document.createElement('div');
                    videoContainer.id = socketId;
                    videoContainer.className = 'video-container';
                    const remoteVideo = document.createElement('video');
                    remoteVideo.autoplay = true;
                    remoteVideo.playsInline = true;
                    const micAudio = document.createElement('audio');
                    micAudio.autoplay = true;
                    micAudio.className = 'mic-audio';
                    const usernameDiv = document.createElement('div');
                    usernameDiv.className = 'username-overlay';
                    usernameDiv.textContent = userData.username;
                    videoContainer.appendChild(remoteVideo);
                    videoContainer.appendChild(micAudio);
                    videoContainer.appendChild(usernameDiv);
                    addPinButton(videoContainer);
                    addClientMuteControls(videoContainer, socket);
                    videoGrid.appendChild(videoContainer);
                    setMuteIndicator(videoContainer, userData.isMuted);
                }

                const videoEl = videoContainer.querySelector('video');
                const audioEl = videoContainer.querySelector('.mic-audio');

                if (event.track.kind === 'video') {
                    // Always put video tracks in the video element.
                    videoEl.srcObject = new MediaStream([event.track]);
                } else if (event.track.kind === 'audio') {
                    // If the invisible audio element is empty, this must be the microphone.
                    if (!audioEl.srcObject) {
                        const micStream = new MediaStream([event.track]);
                        audioEl.srcObject = micStream;

                        // --- Robust Speaking Indicator & Muting via Web Audio ---
                        const audioContext = getSharedAudioContext();
                        // Workaround: Chrome need element muted + playing, but we route audio via API
                        audioEl.muted = true;

                        const source = audioContext.createMediaStreamSource(micStream);
                        const gainNode = audioContext.createGain();
                        const analyser = audioContext.createAnalyser();
                        analyser.fftSize = 256;

                        // Route: Source -> Gain -> Analyser -> Speakers
                        source.connect(gainNode);
                        gainNode.connect(analyser);
                        analyser.connect(audioContext.destination);

                        // Store GainNode
                        remoteGainNodes[socketId] = gainNode;

                        const dataArray = new Uint8Array(analyser.frequencyBinCount);

                        if (audioAnalyzers[socketId]) {
                            cancelAnimationFrame(audioAnalyzers[socketId].loopId);
                        }

                        function checkVolume() {
                            analyser.getByteFrequencyData(dataArray);
                            const average = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;

                            if (average > 15) {
                                videoContainer.classList.add('is-speaking');
                            } else {
                                videoContainer.classList.remove('is-speaking');
                            }
                            if (audioAnalyzers[socketId]) {
                                audioAnalyzers[socketId].loopId = requestAnimationFrame(checkVolume);
                            }
                        }
                        audioAnalyzers[socketId] = { loopId: requestAnimationFrame(checkVolume) };
                        // setupSpeakingIndicator(videoContainer, micStream, socketId); // Replaced by inline logic above
                    } else { // Otherwise, this must be the screen share audio.
                        // Add this audio track to the video element's stream.
                        if (videoEl.srcObject) {
                            videoEl.srcObject.addTrack(event.track);
                        }
                    }
                }
            };

            if (isInitiator) { pc.createOffer().then(offer => pc.setLocalDescription(offer)).then(() => socket.emit('webrtc-offer', socketId, pc.localDescription)); }
        }
        async function toggleScreenShare(isHD, socket) {
            const screenShareBtn = document.getElementById('screen-share-btn');
            if (!isScreenSharing) {
                try {
                    const displayMediaOptions = {
                        video: isHD ? { cursor: "always", width: { ideal: 1920 }, height: { ideal: 1080 }, frameRate: { ideal: 60 } } : true,
                        audio: true
                    };

                    screenStream = await navigator.mediaDevices.getDisplayMedia(displayMediaOptions);
                    isScreenSharing = true;

                    // Show screen on local video
                    localVideo.srcObject = screenStream;
                    localVideo.style.transform = 'scaleX(1)';

                    // --- AUDIO MIXING LOGIC ---
                    // If shared screen has audio, mix it into the destination
                    if (screenStream.getAudioTracks().length > 0) {
                        screenAudioSource = audioContext.createMediaStreamSource(screenStream);
                        screenAudioSource.connect(mixedAudioDest);
                    }

                    // Replace ONLY the video track
                    await replaceTrack(screenStream.getVideoTracks()[0]);

                    screenShareBtn.textContent = 'Stop Sharing';
                    screenShareBtn.classList.add('active');

                    // Handle user clicking "Stop Sharing" on the browser UI
                    screenStream.getVideoTracks()[0].onended = () => { if (isScreenSharing) { toggleScreenShare(false, socket); } };

                } catch (err) { console.error("Screen share error", err); isScreenSharing = false; }
            } else {
                isScreenSharing = false;
                localVideo.srcObject = localStream;
                localVideo.style.transform = 'scaleX(-1)';

                // --- AUDIO CLEANUP LOGIC ---
                if (screenAudioSource) {
                    screenAudioSource.disconnect();
                    screenAudioSource = null;
                }

                // Replace ONLY the video track back to camera
                await replaceTrack(localStream.getVideoTracks()[0]);

                screenShareBtn.textContent = 'Share Screen';
                screenShareBtn.classList.remove('active');

                // Delay stopping the tracks to ensure the replacement frame arrives
                setTimeout(() => {
                    screenStream.getTracks().forEach(track => track.stop());
                }, 500);
            }
        }

        async function replaceTrack(newTrack) {
            for (const pc of Object.values(peerConnections)) {
                // Find the sender responsible for that type of track (video or audio)
                const sender = pc.getSenders().find(s => s.track && s.track.kind === newTrack.kind);
                if (sender) {
                    // Seamlessly replace the track being sent
                    await sender.replaceTrack(newTrack);
                }
            }
        }

        main();

        // --- TAB SWITCHING LOGIC ---
        const tabChat = document.getElementById('tab-chat');
        const tabSystem = document.getElementById('tab-system');
        const listChat = document.getElementById('messages');
        const listSystem = document.getElementById('system-messages');

        tabChat.onclick = () => {
            tabChat.classList.add('active');
            tabSystem.classList.remove('active');
            listChat.style.display = 'block';
            listSystem.style.display = 'none';
        };

        tabSystem.onclick = () => {
            tabSystem.classList.add('active');
            tabChat.classList.remove('active');
            listChat.style.display = 'none';
            listSystem.style.display = 'block';
        };


    </script>

    <div id="quality-modal" class="modal-overlay">
        <div class="modal-content">
            <h2>Choose Screen Share Quality</h2>
            <div class="modal-buttons">
                <button id="standard-quality-btn">Standard</button>
                <button id="hd-quality-btn">High Quality (HD)</button>
            </div>
        </div>
    </div>

</body>

</html>